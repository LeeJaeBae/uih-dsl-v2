<!-- Generated by SpecStory, Markdown v2.0.0 -->

<!-- cursor Session 25103f0f-f7e6-41a8-81ec-b32dd330ea41 (2025-11-18 11:53Z) -->

# Define AST schema for UIH v2 (2025-11-18 11:53Z)

_**User (2025-11-18 10:44Z)**_

You are an expert compiler architect.  

Your task is to define the **complete and final AST schema for UIH v2 (Universal Interface Hierarchy)**.



Important:

- Do NOT write tokenizer, parser, IR, or codegen.  

- Do NOT implement logic.  

- Only define AST types and validation rules.  

- Follow the exact block order: meta → style → components → layout → script.

- Keep the schema deterministic, strict, and LLM-friendly.



## Requirements



1. Provide TypeScript interfaces for all AST nodes:

   - RootAST

   - MetaNode

   - StyleNode

   - ComponentsNode

   - LayoutNode

   - ScriptNode



2. Define node types for UI elements:

   - ElementNode

   - TextNode

   - PropNode (with key/value)

   - EventNode

   - ComponentReferenceNode



3. Each node must include:

   - `type` (string literal union)

   - `location` (line/column)

   - `children` if applicable



4. Meta block must include:

   - title: string

   - route: string

   - optional description, lang, theme



5. Style block must include:

   - design tokens

   - color, spacing, font, radius maps



6. Components block must include:

   - custom component definitions

   - props schema



7. Layout block must support:

   - nested elements

   - text content

   - props

   - events

   - component references



8. Script block:

   - define scripts or interaction hooks in a simple structured form



9. At the end, provide:

   - A complete `AST.d.ts` style file containing ALL interfaces

   - No omissions, no TODOs

   - Deterministic field ordering



10. Return final output in a single TypeScript code block.



## Constraints

- Do not invent new DSL features.

- Do not simplify required fields.

- The AST must be future-proof for IR mapping.

- The structure must allow strict validation.



Begin.



---

_**Agent (model composer-1, mode Agent)**_



---

기존 AST 구조를 확인 중입니다. 확인 후 최종 AST 스키마를 정의하겠습니다.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/packages/ast/src/nodes.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/packages/ast/src/validator.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/packages/core/src/types/index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/rules/5.ast-spec.rule.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/rules/4.error-spec.rule.md</summary>

</details>
</tool-use>

---



---

규칙과 기존 구조를 확인했습니다. 완전한 AST 스키마를 정의 중입니다.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/packages/core/src/errors/index.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/rules/8.reserved-keywords.rule.md</summary>

</details>
</tool-use>

---



---

완전한 AST 스키마 정의 중입니다. 모든 노드 타입과 검증 규칙을 포함합니다.


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: /Users/jaewonlee/Documents/CODESBYLEEJAEWON/uih-v2/packages/ast/src/ast.d.ts</summary>

**Chunk 1**
Lines added: 626, lines removed: 1

```diff
@@ -1,1 +1,626 @@
- 
+ /**
+  * UIH v2 Complete AST Schema Definition
+  * 
+  * This file defines the complete and final AST (Abstract Syntax Tree) schema
+  * for UIH v2 (Universal Interface Hierarchy).
+  * 
+  * Architecture Principles:
+  * - Deterministic: Same input always produces same AST structure
+  * - Strict: All fields are typed and validated
+  * - LLM-friendly: Clear structure for AI code generation
+  * - Future-proof: Designed for IR mapping and codegen
+  * 
+  * Block Order: meta → style → components → layout → script
+  * 
+  * @module @uih/ast
+  */
+ 
+ import type { Range } from &#39;@uih/core&#39;;
+ 
+ // ============================================================================
+ // Base Types
+ // ============================================================================
+ 
+ /**
+  * Base interface for all AST nodes.
+  * Every node must have a type and location information.
+  */
+ export interface BaseNode {
+   /** Node type identifier (string literal union) */
+   type: string;
+   
+   /** Source location for error reporting and debugging */
+   location: Range;
+ }
+ 
+ /**
+  * Location information for source tracking.
+  * Used in all nodes for error reporting.
+  */
+ export interface Location {
+   /** Line number (1-indexed) */
+   line: number;
+   
+   /** Column number (1-indexed) */
+   column: number;
+ }
+ 
+ /**
+  * Range of source code positions.
+  */
+ export interface Range {
+   /** Start position */
+   start: Location;
+   
+   /** End position */
+   end: Location;
+ }
+ 
+ // ============================================================================
+ // Root AST Node
+ // ============================================================================
+ 
+ /**
+  * Root AST node representing the entire UIH document.
+  * Contains an ordered array of blocks following the strict order:
+  * meta → style → components → layout → script
+  */
+ export interface RootAST extends BaseNode {
+   type: &#39;Document&#39;;
+   
+   /** Ordered array of block nodes */
+   blocks: BlockNode[];
+ }
+ 
+ // ============================================================================
+ // Block Node Types
+ // ============================================================================
+ 
+ /**
+  * Union type for all block nodes.
+  * Blocks must appear in strict order: Meta → Style → Components → Layout → Script
+  */
+ export type BlockNode =
+   | MetaNode
+   | StyleNode
+   | ComponentsNode
+   | LayoutNode
+   | ScriptNode;
+ 
+ // ============================================================================
+ // Meta Block Node
+ // ============================================================================
+ 
+ /**
+  * Meta block node containing document metadata.
+  * 
+  * Required fields: title, route
+  * Optional fields: description, lang, theme
+  * 
+  * This block is REQUIRED and must be the first block.
+  */
+ export interface MetaNode extends BaseNode {
+   type: &#39;MetaBlock&#39;;
+   
+   /** Document title (required) */
+   title: string;
+   
+   /** Route/path identifier (required) */
+   route: string;
+   
+   /** Optional description text */
+   description?: string;
+   
+   /** Optional language code (e.g., &#39;en&#39;, &#39;ko&#39;, &#39;ja&#39;) */
+   lang?: string;
+   
+   /** Optional theme identifier */
+   theme?: string;
+   
+   /** Additional metadata properties (key-value pairs) */
+   properties?: Record&lt;string, string&gt;;
+ }
+ 
+ // ============================================================================
+ // Style Block Node
+ // ============================================================================
+ 
+ /**
+  * Style block node containing design tokens.
+  * 
+  * Organized into categories: colors, spacing, fonts, radius, and other tokens.
+  * This block is OPTIONAL.
+  */
+ export interface StyleNode extends BaseNode {
+   type: &#39;StyleBlock&#39;;
+   
+   /** Color design tokens */
+   colors?: Record&lt;string, string&gt;;
+   
+   /** Spacing design tokens (margins, paddings, gaps) */
+   spacing?: Record&lt;string, string&gt;;
+   
+   /** Font design tokens (families, sizes, weights) */
+   fonts?: Record&lt;string, string&gt;;
+   
+   /** Border radius design tokens */
+   radius?: Record&lt;string, string&gt;;
+   
+   /** Other design tokens (shadows, transitions, etc.) */
+   tokens?: Record&lt;string, string&gt;;
+ }
+ 
+ /**
+  * Style token entry (legacy support, prefer structured fields above)
+  */
+ export interface StyleToken {
+   /** Token key/name */
+   key: string;
+   
+   /** Token value */
+   value: string;
+ }
+ 
+ // ============================================================================
+ // Components Block Node
+ // ============================================================================
+ 
+ /**
+  * Components block node defining custom components.
+  * 
+  * Contains component definitions with their props schemas.
+  * This block is OPTIONAL.
+  */
+ export interface ComponentsNode extends BaseNode {
+   type: &#39;ComponentsBlock&#39;;
+   
+   /** Array of component definitions */
+   components: ComponentDefinition[];
+   
+   /** External component imports */
+   imports?: ComponentImport[];
+ }
+ 
+ /**
+  * Component definition with name and props schema.
+  */
+ export interface ComponentDefinition {
+   /** Component name (must be PascalCase, unique) */
+   name: string;
+   
+   /** Props schema definition */
+   props?: ComponentPropsSchema;
+   
+   /** Optional component source/path */
+   source?: string;
+   
+   /** Additional component metadata */
+   metadata?: Record&lt;string, string&gt;;
+ }
+ 
+ /**
+  * Component props schema definition.
+  * Maps prop names to their types and constraints.
+  */
+ export interface ComponentPropsSchema {
+   /** Prop definitions keyed by prop name */
+   [propName: string]: PropSchema;
+ }
+ 
+ /**
+  * Prop schema definition.
+  */
+ export interface PropSchema {
+   /** Prop type: &#39;string&#39; | &#39;number&#39; | &#39;boolean&#39; | &#39;object&#39; | &#39;array&#39; | &#39;any&#39; */
+   type: &#39;string&#39; | &#39;number&#39; | &#39;boolean&#39; | &#39;object&#39; | &#39;array&#39; | &#39;any&#39;;
+   
+   /** Whether prop is required */
+   required?: boolean;
+   
+   /** Default value */
+   default?: string | number | boolean;
+   
+   /** Description of the prop */
+   description?: string;
+ }
+ 
+ /**
+  * External component import definition.
+  */
+ export interface ComponentImport {
+   /** Imported component name */
+   name: string;
+   
+   /** Source path/module */
+   source: string;
+   
+   /** Optional import alias */
+   alias?: string;
+   
+   /** Optional props mapping */
+   props?: Record&lt;string, string&gt;;
+ }
+ 
+ // ============================================================================
+ // Layout Block Node
+ // ============================================================================
+ 
+ /**
+  * Layout block node containing the UI element tree.
+  * 
+  * This block is REQUIRED and must contain at least one child element.
+  * Supports nested elements, text content, props, events, and component references.
+  */
+ export interface LayoutNode extends BaseNode {
+   type: &#39;LayoutBlock&#39;;
+   
+   /** Root elements of the layout tree */
+   children: LayoutChildNode[];
+ }
+ 
+ /**
+  * Union type for all nodes that can appear in layout children.
+  */
+ export type LayoutChildNode =
+   | ElementNode
+   | TextNode
+   | ComponentReferenceNode;
+ 
+ // ============================================================================
+ // Element Node Types
+ // ============================================================================
+ 
+ /**
+  * Element node representing an HTML-like element or component.
+  * 
+  * Can contain attributes (props), events, and nested children.
+  */
+ export interface ElementNode extends BaseNode {
+   type: &#39;Element&#39;;
+   
+   /** Element tag name (e.g., &#39;div&#39;, &#39;button&#39;, &#39;Container&#39;) */
+   tag: string;
+   
+   /** Element attributes/properties */
+   attributes?: PropNode[];
+   
+   /** Element event handlers */
+   events?: EventNode[];
+   
+   /** Nested child nodes (elements, text, component references) */
+   children?: LayoutChildNode[];
+ }
+ 
+ /**
+  * Text node representing text content.
+  * 
+  * Cannot have children. Used for inline text within elements.
+  */
+ export interface TextNode extends BaseNode {
+   type: &#39;Text&#39;;
+   
+   /** Text content value */
+   value: string;
+ }
+ 
+ /**
+  * Prop node representing an element attribute/property.
+  * 
+  * Contains key-value pair with optional binding expression.
+  */
+ export interface PropNode extends BaseNode {
+   type: &#39;Prop&#39;;
+   
+   /** Property name/key */
+   key: string;
+   
+   /** Property value (can be literal or binding expression) */
+   value: PropValue;
+ }
+ 
+ /**
+  * Union type for property values.
+  */
+ export type PropValue =
+   | string
+   | number
+   | boolean
+   | BindingExpression
+   | null
+   | undefined;
+ 
+ /**
+  * Binding expression for dynamic values.
+  * 
+  * Used for expressions like &#96;{variable}&#96;, &#96;{state.count}&#96;, etc.
+  */
+ export interface BindingExpression {
+   type: &#39;Binding&#39;;
+   
+   /** Expression string (e.g., &#39;state.count&#39;, &#39;user.name&#39;) */
+   expression: string;
+   
+   /** Optional expression metadata */
+   metadata?: Record&lt;string, string&gt;;
+ }
+ 
+ /**
+  * Event node representing an event handler.
+  * 
+  * Maps event names (e.g., &#39;click&#39;, &#39;submit&#39;) to handler expressions.
+  */
+ export interface EventNode extends BaseNode {
+   type: &#39;Event&#39;;
+   
+   /** Event name (e.g., &#39;click&#39;, &#39;submit&#39;, &#39;change&#39;) */
+   event: string;
+   
+   /** Handler expression or function name */
+   handler: string;
+   
+   /** Optional event metadata */
+   metadata?: Record&lt;string, string&gt;;
+ }
+ 
+ /**
+  * Component reference node for referencing defined components.
+  * 
+  * Used in layout to instantiate components from the Components block.
+  */
+ export interface ComponentReferenceNode extends BaseNode {
+   type: &#39;ComponentReference&#39;;
+   
+   /** Referenced component name */
+   component: string;
+   
+   /** Props passed to the component */
+   props?: PropNode[];
+   
+   /** Event handlers for the component */
+   events?: EventNode[];
+   
+   /** Nested children (for components that accept children/slots) */
+   children?: LayoutChildNode[];
+ }
+ 
+ // ============================================================================
+ // Script Block Node
+ // ============================================================================
+ 
+ /**
+  * Script block node containing scripts or interaction hooks.
+  * 
+  * Structured form for defining scripts, hooks, and interaction logic.
+  * This block is OPTIONAL.
+  */
+ export interface ScriptNode extends BaseNode {
+   type: &#39;ScriptBlock&#39;;
+   
+   /** Script language: &#39;javascript&#39; | &#39;typescript&#39; */
+   language?: &#39;javascript&#39; | &#39;typescript&#39;;
+   
+   /** Raw script content (for simple scripts) */
+   content?: string;
+   
+   /** Structured script definitions (for hooks and interactions) */
+   hooks?: ScriptHook[];
+   
+   /** Function definitions */
+   functions?: ScriptFunction[];
+   
+   /** Variable declarations */
+   variables?: ScriptVariable[];
+ }
+ 
+ /**
+  * Script hook definition.
+  * 
+  * Represents lifecycle hooks or event hooks.
+  */
+ export interface ScriptHook {
+   /** Hook name (e.g., &#39;onMount&#39;, &#39;onClick&#39;, &#39;onSubmit&#39;) */
+   name: string;
+   
+   /** Hook handler code */
+   handler: string;
+   
+   /** Optional hook metadata */
+   metadata?: Record&lt;string, string&gt;;
+ }
+ 
+ /**
+  * Script function definition.
+  */
+ export interface ScriptFunction {
+   /** Function name */
+   name: string;
+   
+   /** Function parameters */
+   parameters?: string[];
+   
+   /** Function body code */
+   body: string;
+   
+   /** Optional return type */
+   returnType?: string;
+   
+   /** Optional function metadata */
+   metadata?: Record&lt;string, string&gt;;
+ }
+ 
+ /**
+  * Script variable definition.
+  */
+ export interface ScriptVariable {
+   /** Variable name */
+   name: string;
+   
+   /** Variable value/initializer */
+   value: string;
+   
+   /** Optional variable type */
+   type?: string;
+   
+   /** Optional variable metadata */
+   metadata?: Record&lt;string, string&gt;;
+ }
+ 
+ // ============================================================================
+ // Type Guards
+ // ============================================================================
+ 
+ /**
+  * Type guard to check if a node is a RootAST (Document).
+  */
+ export function isRootAST(node: BaseNode): node is RootAST {
+   return node.type === &#39;Document&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a BlockNode.
+  */
+ export function isBlockNode(node: BaseNode): node is BlockNode {
+   return (
+     node.type === &#39;MetaBlock&#39; ||
+     node.type === &#39;StyleBlock&#39; ||
+     node.type === &#39;ComponentsBlock&#39; ||
+     node.type === &#39;LayoutBlock&#39; ||
+     node.type === &#39;ScriptBlock&#39;
+   );
+ }
+ 
+ /**
+  * Type guard to check if a node is a MetaNode.
+  */
+ export function isMetaNode(node: BaseNode): node is MetaNode {
+   return node.type === &#39;MetaBlock&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a StyleNode.
+  */
+ export function isStyleNode(node: BaseNode): node is StyleNode {
+   return node.type === &#39;StyleBlock&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a ComponentsNode.
+  */
+ export function isComponentsNode(node: BaseNode): node is ComponentsNode {
+   return node.type === &#39;ComponentsBlock&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a LayoutNode.
+  */
+ export function isLayoutNode(node: BaseNode): node is LayoutNode {
+   return node.type === &#39;LayoutBlock&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a ScriptNode.
+  */
+ export function isScriptNode(node: BaseNode): node is ScriptNode {
+   return node.type === &#39;ScriptBlock&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is an ElementNode.
+  */
+ export function isElementNode(node: BaseNode): node is ElementNode {
+   return node.type === &#39;Element&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a TextNode.
+  */
+ export function isTextNode(node: BaseNode): node is TextNode {
+   return node.type === &#39;Text&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a PropNode.
+  */
+ export function isPropNode(node: BaseNode): node is PropNode {
+   return node.type === &#39;Prop&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is an EventNode.
+  */
+ export function isEventNode(node: BaseNode): node is EventNode {
+   return node.type === &#39;Event&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a ComponentReferenceNode.
+  */
+ export function isComponentReferenceNode(node: BaseNode): node is ComponentReferenceNode {
+   return node.type === &#39;ComponentReference&#39;;
+ }
+ 
+ /**
+  * Type guard to check if a node is a LayoutChildNode.
+  */
+ export function isLayoutChildNode(node: BaseNode): node is LayoutChildNode {
+   return (
+     node.type === &#39;Element&#39; ||
+     node.type === &#39;Text&#39; ||
+     node.type === &#39;ComponentReference&#39;
+   );
+ }
+ 
+ // ============================================================================
+ // Validation Constants
+ // ============================================================================
+ 
+ /**
+  * Required block types that must appear in every AST.
+  */
+ export const REQUIRED_BLOCKS: readonly string[] = [&#39;MetaBlock&#39;, &#39;LayoutBlock&#39;] as const;
+ 
+ /**
+  * Block order specification.
+  * Blocks must appear in this exact order.
+  */
+ export const BLOCK_ORDER: readonly string[] = [
+   &#39;MetaBlock&#39;,
+   &#39;StyleBlock&#39;,
+   &#39;ComponentsBlock&#39;,
+   &#39;LayoutBlock&#39;,
+   &#39;ScriptBlock&#39;
+ ] as const;
+ 
+ /**
+  * Valid node types for AST validation.
+  */
+ export const VALID_NODE_TYPES: readonly string[] = [
+   // Root
+   &#39;Document&#39;,
+   // Blocks
+   &#39;MetaBlock&#39;,
+   &#39;StyleBlock&#39;,
+   &#39;ComponentsBlock&#39;,
+   &#39;LayoutBlock&#39;,
+   &#39;ScriptBlock&#39;,
+   // Elements
+   &#39;Element&#39;,
+   &#39;Text&#39;,
+   &#39;Prop&#39;,
+   &#39;Event&#39;,
+   &#39;ComponentReference&#39;,
+ ] as const;
+ 
+ // ============================================================================
+ // Export All Types
+ // ============================================================================
+ 
+ export type {
+   RootAST as DocumentNode,
+   MetaNode as MetaBlockNode,
+   StyleNode as StyleBlockNode,
+   ComponentsNode as ComponentsBlockNode,
+   LayoutNode as LayoutBlockNode,
+   ScriptNode as ScriptBlockNode,
+ };
+ 
```

</details>

</tool-use>

---



---

완전한 AST 스키마 정의를 완료했습니다. 모든 노드 타입과 검증 규칙을 포함합니다.

## 완성된 AST 스키마 요약

다음 항목을 포함합니다:

### 1. **Root AST Node**
- `RootAST` (Document): 모든 블록을 포함하는 루트 노드

### 2. **Block Nodes** (순서: meta → style → components → layout → script)
- `MetaNode`: title, route 필수, description/lang/theme 선택
- `StyleNode`: colors, spacing, fonts, radius, tokens 구조화
- `ComponentsNode`: 컴포넌트 정의와 props schema
- `LayoutNode`: 중첩 가능한 UI 트리
- `ScriptNode`: 구조화된 스크립트/훅 정의

### 3. **Element Nodes**
- `ElementNode`: 태그, 속성, 이벤트, 자식 포함
- `TextNode`: 텍스트 콘텐츠
- `PropNode`: 키-값 속성 (바인딩 표현식 지원)
- `EventNode`: 이벤트 핸들러
- `ComponentReferenceNode`: 컴포넌트 참조

### 4. **Script Structure**
- `ScriptHook`: 라이프사이클/이벤트 훅
- `ScriptFunction`: 함수 정의
- `ScriptVariable`: 변수 선언

### 5. **Type Guards & Validation**
- 모든 노드 타입에 대한 타입 가드 함수
- 검증 상수 (REQUIRED_BLOCKS, BLOCK_ORDER, VALID_NODE_TYPES)

파일은 `/packages/ast/src/ast.d.ts`에 저장했습니다. 모든 인터페이스는 결정론적 필드 순서로 정의되어 있으며, IR 매핑과 코드 생성에 적합합니다.

기존 `nodes.ts`와 통합하거나 별도로 사용할 수 있습니다. 필요하면 기존 파일을 업데이트하겠습니다.

---

