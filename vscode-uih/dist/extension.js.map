{"version":3,"sources":["../src/extension.ts","../../compiler/packages/tokenizer/src/types.ts","../../compiler/packages/tokenizer/src/tokenizer.ts","../../compiler/packages/parser/src/parser.ts","../../compiler/packages/ir/src/normalize.ts","../../compiler/packages/ir/src/translator.ts","../../compiler/packages/codegen/react/src/meta.ts","../../compiler/packages/codegen/react/src/style.ts","../../compiler/packages/codegen/react/src/script.ts","../../compiler/packages/codegen/react/src/jsx.ts","../../compiler/packages/codegen/react/src/generator.ts","../../compiler/packages/codegen/vue/src/meta.ts","../../compiler/packages/codegen/vue/src/style.ts","../../compiler/packages/codegen/vue/src/script.ts","../../compiler/packages/codegen/vue/src/template.ts","../../compiler/packages/codegen/vue/src/generator.ts","../../compiler/packages/codegen/svelte/src/meta.ts","../../compiler/packages/codegen/svelte/src/style.ts","../../compiler/packages/codegen/svelte/src/script.ts","../../compiler/packages/codegen/svelte/src/template.ts","../../compiler/packages/codegen/svelte/src/generator.ts"],"sourcesContent":["/**\n * UIH VSCode Extension v2\n * Updated for UIH DSL v2 specification\n */\n\nimport * as vscode from \"vscode\";\nimport { tokenize } from \"@uih-dsl/tokenizer\";\nimport { parse } from \"@uih-dsl/parser\";\nimport { createIR } from \"@uih-dsl/ir\";\nimport { generate as generateReact } from \"@uih-dsl/codegen-react\";\nimport { generate as generateVue } from \"@uih-dsl/codegen-vue\";\nimport { generate as generateSvelte } from \"@uih-dsl/codegen-svelte\";\nimport type { ASTRoot } from \"@uih-dsl/parser\";\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function activate(context: vscode.ExtensionContext) {\n  console.log('UIH v2 extension activated');\n\n  // Register preview command\n  const previewCommand = vscode.commands.registerCommand(\n    \"uih.preview\",\n    async () => {\n      await handlePreview(context);\n    }\n  );\n\n  // Register compile command\n  const compileCommand = vscode.commands.registerCommand(\n    \"uih.compile\",\n    async () => {\n      await handleCompile();\n    }\n  );\n\n  context.subscriptions.push(previewCommand, compileCommand);\n\n  // Auto-preview if enabled\n  const config = vscode.workspace.getConfiguration(\"uih\");\n  if (config.get(\"autoPreview\")) {\n    vscode.window.onDidChangeActiveTextEditor((editor) => {\n      if (editor && editor.document.languageId === \"uih\") {\n        handlePreview(context);\n      }\n    });\n  }\n}\n\n/**\n * Preview compiled UI\n */\nasync function handlePreview(context: vscode.ExtensionContext) {\n  const editor = vscode.window.activeTextEditor;\n\n  if (!editor || editor.document.languageId !== \"uih\") {\n    vscode.window.showErrorMessage(\"Open a .uih file to preview\");\n    return;\n  }\n\n  const uihCode = editor.document.getText();\n\n  try {\n    // Step 1: Tokenize\n    const tokens = tokenize(uihCode);\n\n    // Step 2: Parse\n    const parseResult = parse(tokens);\n\n    if (parseResult.errors.length > 0) {\n      const errorMsg = parseResult.errors\n        .map((err) => {\n          const loc = err.location ? ` at line ${err.location.line}, column ${err.location.column}` : \"\";\n          return `${err.message}${loc}`;\n        })\n        .join(\"\\n\");\n      vscode.window.showErrorMessage(`Parse errors:\\n${errorMsg}`);\n      return;\n    }\n\n    if (!parseResult.ast) {\n      vscode.window.showErrorMessage(\"Failed to parse UIH file\");\n      return;\n    }\n\n    // Create webview panel\n    const panel = vscode.window.createWebviewPanel(\n      \"uihPreview\",\n      \"UIH Live Preview\",\n      vscode.ViewColumn.Beside,\n      {\n        enableScripts: true,\n        localResourceRoots: [],\n      }\n    );\n\n    // Set HTML content with live UI rendering\n    panel.webview.html = getPreviewHtml(parseResult.ast);\n  } catch (error: any) {\n    vscode.window.showErrorMessage(`Preview failed: ${error.message}`);\n  }\n}\n\n/**\n * Compile UIH to target framework\n */\nasync function handleCompile() {\n  const editor = vscode.window.activeTextEditor;\n\n  if (!editor || editor.document.languageId !== \"uih\") {\n    vscode.window.showErrorMessage(\"Open a .uih file to compile\");\n    return;\n  }\n\n  // Ask for target framework\n  const target = await vscode.window.showQuickPick([\"react\", \"vue\", \"svelte\"], {\n    placeHolder: \"Select target framework\",\n  });\n\n  if (!target) {\n    return;\n  }\n\n  const uihCode = editor.document.getText();\n\n  try {\n    // Step 1: Tokenize\n    const tokens = tokenize(uihCode);\n\n    // Step 2: Parse\n    const parseResult = parse(tokens);\n\n    if (parseResult.errors.length > 0) {\n      const errorMsg = parseResult.errors\n        .map((err) => `${err.message}`)\n        .join(\"\\n\");\n      vscode.window.showErrorMessage(`Parse errors:\\n${errorMsg}`);\n      return;\n    }\n\n    if (!parseResult.ast) {\n      vscode.window.showErrorMessage(\"Failed to parse UIH file\");\n      return;\n    }\n\n    // Step 3: Create IR\n    const irResult = createIR(parseResult.ast, parseResult.errors);\n\n    if (irResult.errors.length > 0) {\n      const errorMsg = irResult.errors.map((err) => err.message).join(\"\\n\");\n      vscode.window.showErrorMessage(`IR errors:\\n${errorMsg}`);\n      return;\n    }\n\n    // Step 4: Generate code\n    let codeResult;\n    let fileExtension;\n    let language;\n\n    switch (target) {\n      case \"react\":\n        codeResult = generateReact(irResult);\n        fileExtension = \".tsx\";\n        language = \"typescriptreact\";\n        break;\n      case \"vue\":\n        codeResult = generateVue(irResult);\n        fileExtension = \".vue\";\n        language = \"vue\";\n        break;\n      case \"svelte\":\n        codeResult = generateSvelte(irResult);\n        fileExtension = \".svelte\";\n        language = \"svelte\";\n        break;\n      default:\n        vscode.window.showErrorMessage(`Unknown target: ${target}`);\n        return;\n    }\n\n    // Create output file\n    const fileName = `Page${fileExtension}`;\n    const doc = await vscode.workspace.openTextDocument({\n      language: language,\n      content: codeResult.code,\n    });\n\n    await vscode.window.showTextDocument(doc, vscode.ViewColumn.Beside);\n\n    vscode.window.showInformationMessage(`âœ… Compiled to ${target}`);\n  } catch (error: any) {\n    vscode.window.showErrorMessage(`Compilation failed: ${error.message}`);\n  }\n}\n\n/**\n * Generate preview HTML with live UI rendering\n */\nfunction getPreviewHtml(ast: ASTRoot): string {\n  // Extract style properties\n  const cssVars = ast.style.properties.length > 0\n    ? generateCSSVariables(ast.style.properties)\n    : \"\";\n\n  // Extract layout nodes\n  const htmlContent = ast.layout.children.length > 0\n    ? renderNodes(ast.layout.children)\n    : \"<p>No layout found</p>\";\n\n  return `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n  <style>\n    ${cssVars}\n    body { margin: 0; padding: 0; }\n  </style>\n</head>\n<body>\n  ${htmlContent}\n</body>\n</html>`;\n}\n\n/**\n * Generate CSS variables from style properties\n */\nfunction generateCSSVariables(properties: Array<{ key: string; value: string }>): string {\n  const vars = properties\n    .map(({ key, value }) => `  --${key.replace(/\\./g, \"-\")}: ${value};`)\n    .join(\"\\n\");\n  return vars ? `:root {\\n${vars}\\n}` : \"\";\n}\n\n/**\n * Render UIH nodes to HTML\n */\nfunction renderNodes(nodes: any[]): string {\n  return nodes.map((node) => renderNode(node)).join(\"\\n\");\n}\n\n/**\n * Render a single UIH node to HTML\n */\nfunction renderNode(node: any): string {\n  if (node.type === \"Text\") {\n    return escapeHtml(node.value);\n  }\n\n  if (node.type === \"Component\") {\n    return renderElement(node);\n  }\n\n  return \"\";\n}\n\n/**\n * Render an element node to HTML\n */\nfunction renderElement(node: any): string {\n  const tagName = getHTMLTag(node.tag);\n  const attrs = renderAttributes(node.attributes);\n  const children = node.children ? renderNodes(node.children) : \"\";\n\n  // Self-closing tags\n  if ([\"img\", \"input\", \"br\", \"hr\"].includes(tagName.toLowerCase())) {\n    return `<${tagName}${attrs} />`;\n  }\n\n  return `<${tagName}${attrs}>${children}</${tagName}>`;\n}\n\n/**\n * Map UIH element names to HTML tags\n */\nfunction getHTMLTag(name: string): string {\n  const htmlElements: Record<string, string> = {\n    // Layout\n    Div: \"div\",\n    Section: \"section\",\n    Article: \"article\",\n    Aside: \"aside\",\n    Header: \"header\",\n    Footer: \"footer\",\n    Nav: \"nav\",\n    Main: \"main\",\n    // Text\n    H1: \"h1\",\n    H2: \"h2\",\n    H3: \"h3\",\n    H4: \"h4\",\n    H5: \"h5\",\n    H6: \"h6\",\n    P: \"p\",\n    Span: \"span\",\n    Text: \"span\",\n    // Form\n    Form: \"form\",\n    Input: \"input\",\n    Textarea: \"textarea\",\n    Button: \"button\",\n    Label: \"label\",\n    Select: \"select\",\n    Option: \"option\",\n    // List\n    Ul: \"ul\",\n    Ol: \"ol\",\n    Li: \"li\",\n    // Table\n    Table: \"table\",\n    Thead: \"thead\",\n    Tbody: \"tbody\",\n    Tr: \"tr\",\n    Td: \"td\",\n    Th: \"th\",\n    // Media\n    Img: \"img\",\n    Video: \"video\",\n    Audio: \"audio\",\n    // Other\n    A: \"a\",\n    Card: \"div\",\n    CardContent: \"div\",\n  };\n\n  return htmlElements[name] || \"div\";\n}\n\n/**\n * Render element attributes\n */\nfunction renderAttributes(attrs: Array<{ key: string; value: string }>): string {\n  if (!attrs || attrs.length === 0) return \"\";\n\n  const attrStrings = attrs.map((attr) => {\n    const value = escapeHtml(attr.value);\n    return `${attr.key}=\"${value}\"`;\n  }).join(\" \");\n\n  return \" \" + attrStrings;\n}\n\n/**\n * Escape HTML special characters\n */\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n\nexport function deactivate() {\n  console.log('UIH v2 extension deactivated');\n}\n","/**\n * Shared tokenizer type definitions.\n *\n * @module @src/types\n * @version 1.0.0\n */\n\n/**\n * Token types emitted by the tokenizer.\n *\n * @public\n */\nexport enum TokenType {\n  // Identifiers and names\n  IDENTIFIER = \"IDENTIFIER\", // meta, title, color.primary, class (lowercase start)\n  TAGNAME = \"TAGNAME\", // Div, Header, H1 (uppercase start)\n\n  // Literals\n  STRING = \"STRING\", // \"value\" - all quoted strings (distinction is Parser's job)\n  NUMBER = \"NUMBER\", // 12, 0.5\n  BOOLEAN = \"BOOLEAN\", // true, false\n\n  // Symbols\n  LBRACE = \"LBRACE\", // {\n  RBRACE = \"RBRACE\", // }\n  LPAREN = \"LPAREN\", // (\n  RPAREN = \"RPAREN\", // )\n  COLON = \"COLON\", // :\n  COMMA = \"COMMA\", // ,\n\n  // Whitespace\n  NEWLINE = \"NEWLINE\", // \\n (only newlines are tokenized, spaces are skipped)\n\n  // Special\n  EOF = \"EOF\", // End of file\n}\n\n/**\n * Capture an absolute position inside the source text.\n *\n * @public\n */\nexport interface Position {\n  line: number;\n  column: number;\n  index: number; // Absolute position in string\n}\n\n/**\n * Represents a start/end range for any token.\n *\n * @public\n */\nexport interface Range {\n  start: Position;\n  end: Position;\n}\n\n/**\n * Normalized token record produced by the tokenizer.\n *\n * @public\n */\nexport interface Token {\n  type: TokenType;\n  value: string;\n  range: Range;\n\n  // v2.1 metadata\n  modeAtToken: TokenizerMode; // Mode when this token was created\n  rawIndex: number; // Original index in source (same as range.start.index)\n\n  // Optional flags for Parser hints\n  /**\n   * Set to `true` when this token is an IDENTIFIER with value \"layout\".\n   * Allows Parser to quickly identify potential layout block starts without string comparison.\n   * Parser should verify that the next non-whitespace token is LBRACE to confirm layout block.\n   */\n  isPotentialLayoutStart?: boolean;\n}\n\n/**\n * Tokenizer context modes used for FSM-based tokenization.\n *\n * @public\n */\nexport enum TokenizerMode {\n  NORMAL = \"NORMAL\", // Default mode for top-level constructs\n  ATTRIBUTES = \"ATTRIBUTES\", // Inside component attributes (between parentheses)\n  STRING_LITERAL = \"STRING_LITERAL\", // Inside a string literal\n}\n\n/**\n * Shape of tokenizer error payloads.\n *\n * @public\n */\nexport interface TokenizerError {\n  message: string;\n  position: Position;\n  char?: string;\n}\n","/**\n * UIH DSL Tokenizer implementation entrypoint.\n *\n * Refactored to be fully deterministic and spec-compliant.\n * The tokenizer operates as a mode-based FSM without semantic interpretation.\n * Context-aware token classification (e.g., TEXT_STRING) is delegated to the Parser.\n *\n * @module @src/tokenizer\n * @version 2.1.0\n */\n\nimport {\n  Token,\n  TokenType,\n  Position,\n  TokenizerMode,\n} from \"./types.js\";\n\n/**\n * Stateful tokenizer that converts UIH DSL source text into a token stream.\n *\n * Design principles:\n * - Deterministic character-by-character scanning\n * - Mode-based FSM for context handling (NORMAL, ATTRIBUTES, STRING_LITERAL)\n * - No semantic interpretation (Parser's responsibility)\n * - Strict validation of forbidden characters and syntax rules\n *\n * v2.1 improvements:\n * - Token metadata: modeAtToken, rawIndex\n * - isPotentialLayoutStart flag for \"layout\" identifiers\n * - FSM-based Identifier/TagName parsing (no regex duplication)\n * - STRING_LITERAL mode properly utilized\n * - Improved backslash handling in forbidden characters\n *\n * @public\n */\nexport class Tokenizer {\n  private input: string;\n  private index: number = 0;\n  private line: number = 1;\n  private column: number = 1;\n  private tokens: Token[] = [];\n\n  // FSM mode stack\n  private mode: TokenizerMode = TokenizerMode.NORMAL;\n  private modeStack: TokenizerMode[] = [];\n\n  /**\n   * Create a new tokenizer instance.\n   *\n   * @param input - Raw DSL source text (LF line endings, no tabs).\n   * @throws {Error} If CRLF or tab characters are detected.\n   */\n  constructor(input: string) {\n    // Validate input - no CRLF, no tabs\n    if (input.includes(\"\\r\\n\")) {\n      throw new Error(\"CRLF line endings not allowed. Use LF (\\\\n) only.\");\n    }\n    if (input.includes(\"\\t\")) {\n      throw new Error(\n        \"Tab characters not allowed. Use spaces for indentation.\"\n      );\n    }\n\n    this.input = input;\n  }\n\n  /**\n   * Convert the current input into a list of tokens.\n   *\n   * @returns Ordered list of tokens ending with `TokenType.EOF`.\n   */\n  public tokenize(): Token[] {\n    this.tokens = [];\n    this.index = 0;\n    this.line = 1;\n    this.column = 1;\n    this.mode = TokenizerMode.NORMAL;\n    this.modeStack = [];\n\n    while (this.index < this.input.length) {\n      this.skipWhitespace();\n\n      if (this.index >= this.input.length) {\n        break;\n      }\n\n      const token = this.nextToken();\n      if (token) {\n        this.tokens.push(token);\n      }\n    }\n\n    // Add EOF token\n    this.tokens.push(\n      this.createToken(\n        TokenType.EOF,\n        \"\",\n        this.getPosition(),\n        this.getPosition()\n      )\n    );\n\n    return this.tokens;\n  }\n\n  /**\n   * Read the next token from the input stream.\n   *\n   * @returns The next token or `null` if no token can be produced.\n   * @throws {Error} When encountering forbidden/unexpected characters.\n   */\n  private nextToken(): Token | null {\n    const startPos = this.getPosition();\n    const char = this.peek();\n\n    // Check for forbidden characters first (but not backslash in strings)\n    if (this.mode !== TokenizerMode.STRING_LITERAL && this.isForbiddenChar(char)) {\n      throw this.createError(`Forbidden character '${char}'`, startPos);\n    }\n\n    // Newline\n    if (char === \"\\n\") {\n      this.advance();\n      this.line++;\n      this.column = 1;\n      return this.createToken(\n        TokenType.NEWLINE,\n        \"\\n\",\n        startPos,\n        this.getPosition()\n      );\n    }\n\n    // Symbols\n    if (char === \"{\") {\n      this.advance();\n      return this.createToken(\n        TokenType.LBRACE,\n        \"{\",\n        startPos,\n        this.getPosition()\n      );\n    }\n    if (char === \"}\") {\n      this.advance();\n      return this.createToken(\n        TokenType.RBRACE,\n        \"}\",\n        startPos,\n        this.getPosition()\n      );\n    }\n    if (char === \"(\") {\n      this.advance();\n      this.pushMode(TokenizerMode.ATTRIBUTES);\n      return this.createToken(\n        TokenType.LPAREN,\n        \"(\",\n        startPos,\n        this.getPosition()\n      );\n    }\n    if (char === \")\") {\n      this.advance();\n      this.popMode();\n      return this.createToken(\n        TokenType.RPAREN,\n        \")\",\n        startPos,\n        this.getPosition()\n      );\n    }\n    if (char === \":\") {\n      this.advance();\n      return this.createToken(\n        TokenType.COLON,\n        \":\",\n        startPos,\n        this.getPosition()\n      );\n    }\n    if (char === \",\") {\n      this.advance();\n      return this.createToken(\n        TokenType.COMMA,\n        \",\",\n        startPos,\n        this.getPosition()\n      );\n    }\n\n    // String\n    if (char === '\"') {\n      return this.readString();\n    }\n\n    // Number\n    if (this.isDigit(char)) {\n      return this.readNumber();\n    }\n\n    // Identifier or TagName or Boolean\n    if (this.isLetter(char)) {\n      return this.readIdentifierOrTagName();\n    }\n\n    throw this.createError(`Unexpected character '${char}'`, startPos);\n  }\n\n  /**\n   * Read a quoted string literal with STRING_LITERAL mode.\n   * All strings are tokenized as STRING - context interpretation is Parser's job.\n   *\n   * Escape sequence policy (Strategy A - Minimal):\n   * - Only \\\" is allowed (escaped quote)\n   * - All other escape sequences are errors\n   * - This keeps the language simple and predictable\n   *\n   * @returns The parsed string token.\n   * @throws {Error} If a newline, EOF, or invalid escape is encountered.\n   */\n  private readString(): Token {\n    const startPos = this.getPosition();\n    let value = \"\";\n\n    // Enter STRING_LITERAL mode\n    this.pushMode(TokenizerMode.STRING_LITERAL);\n\n    this.advance(); // Skip opening quote\n\n    while (this.index < this.input.length && this.peek() !== '\"') {\n      if (this.peek() === \"\\\\\") {\n        // Handle escape sequences - Strategy A: only \\\" allowed\n        const escapePos = this.getPosition();\n        this.advance(); // Skip backslash\n        const nextChar = this.peek();\n\n        if (nextChar === '\"') {\n          // Only valid escape: \\\"\n          value += '\"';\n          this.advance();\n        } else {\n          // All other escapes are errors\n          this.popMode(); // Exit mode before throwing\n          throw this.createError(\n            `Invalid escape sequence '\\\\${nextChar}' - only \\\\\" is allowed in strings`,\n            escapePos\n          );\n        }\n      } else if (this.peek() === \"\\n\") {\n        // Exit STRING_LITERAL mode before throwing\n        this.popMode();\n        throw this.createError(\n          \"Unterminated string (newline not allowed)\",\n          this.getPosition()\n        );\n      } else {\n        value += this.peek();\n        this.advance();\n      }\n    }\n\n    if (this.index >= this.input.length) {\n      // Exit STRING_LITERAL mode before throwing\n      this.popMode();\n      throw this.createError(\"Unterminated string (EOF)\", startPos);\n    }\n\n    this.advance(); // Skip closing quote\n\n    // Exit STRING_LITERAL mode\n    this.popMode();\n\n    // All strings are STRING tokens - Parser determines if it's text content\n    return this.createToken(TokenType.STRING, value, startPos, this.getPosition());\n  }\n\n  /**\n   * Read a numeric literal supporting optional decimals.\n   *\n   * @returns The parsed number token.\n   */\n  private readNumber(): Token {\n    const startPos = this.getPosition();\n    let value = \"\";\n\n    // Read integer part\n    while (this.isDigit(this.peek())) {\n      value += this.peek();\n      this.advance();\n    }\n\n    // Read decimal part if exists\n    if (this.peek() === \".\" && this.isDigit(this.peekNext())) {\n      value += \".\";\n      this.advance();\n\n      while (this.isDigit(this.peek())) {\n        value += this.peek();\n        this.advance();\n      }\n    }\n\n    return this.createToken(\n      TokenType.NUMBER,\n      value,\n      startPos,\n      this.getPosition()\n    );\n  }\n\n  /**\n   * Read identifiers, booleans, or tag names using FSM-based parsing.\n   * No regex duplication - single pass validation.\n   *\n   * Rules:\n   * - Identifier: lowercase start, then lowercase + digits + dots\n   *   - No consecutive dots\n   *   - No leading/trailing dots\n   * - TagName: uppercase start, then alphanumeric only (no underscores)\n   *\n   * @returns The parsed identifier-related token.\n   * @throws {Error} If identifier/tagname rules are violated.\n   */\n  private readIdentifierOrTagName(): Token {\n    const startPos = this.getPosition();\n    let value = \"\";\n\n    // Check if uppercase (TagName) or lowercase (Identifier)\n    const firstChar = this.peek();\n    const isTagName = this.isUpperCase(firstChar);\n\n    if (isTagName) {\n      // TagName FSM: [A-Z][a-zA-Z0-9]*\n      value += firstChar;\n      this.advance();\n\n      while (this.index < this.input.length) {\n        const char = this.peek();\n\n        if (this.isLetter(char) || this.isDigit(char)) {\n          value += char;\n          this.advance();\n        } else if (char === \"_\") {\n          // Explicitly forbid underscore\n          throw this.createError(\n            \"TagName cannot contain underscores\",\n            this.getPosition()\n          );\n        } else {\n          // End of TagName\n          break;\n        }\n      }\n\n      return this.createToken(\n        TokenType.TAGNAME,\n        value,\n        startPos,\n        this.getPosition()\n      );\n    } else {\n      // Identifier FSM: [a-z][a-z0-9.]* with validation\n      if (!this.isLowerCase(firstChar)) {\n        throw this.createError(\n          \"Identifier must start with lowercase letter\",\n          startPos\n        );\n      }\n\n      value += firstChar;\n      this.advance();\n\n      let lastWasDot = false;\n\n      while (this.index < this.input.length) {\n        const char = this.peek();\n\n        if (this.isLowerCase(char) || this.isDigit(char)) {\n          value += char;\n          lastWasDot = false;\n          this.advance();\n        } else if (char === \".\") {\n          // Check for consecutive dots\n          if (lastWasDot) {\n            throw this.createError(\n              \"Identifier cannot contain consecutive dots\",\n              this.getPosition()\n            );\n          }\n          value += char;\n          lastWasDot = true;\n          this.advance();\n        } else {\n          // End of Identifier\n          break;\n        }\n      }\n\n      // Validate no trailing dot\n      if (value.endsWith(\".\")) {\n        throw this.createError(\n          \"Identifier cannot end with a dot\",\n          this.getPosition()\n        );\n      }\n\n      // Check for boolean keywords\n      if (value === \"true\" || value === \"false\") {\n        return this.createToken(\n          TokenType.BOOLEAN,\n          value,\n          startPos,\n          this.getPosition()\n        );\n      }\n\n      // Create identifier token with optional layout flag\n      return this.createToken(\n        TokenType.IDENTIFIER,\n        value,\n        startPos,\n        this.getPosition(),\n        value === \"layout\" // isPotentialLayoutStart\n      );\n    }\n  }\n\n  /**\n   * Skip plain space characters (not tabs, not newlines).\n   * Only spaces are skipped - newlines are tokenized.\n   */\n  private skipWhitespace(): void {\n    while (this.peek() === \" \") {\n      this.advance();\n    }\n  }\n\n  /**\n   * Push the current tokenizer mode onto the stack and switch to a new mode.\n   *\n   * @param mode - Mode to activate.\n   */\n  private pushMode(mode: TokenizerMode): void {\n    this.modeStack.push(this.mode);\n    this.mode = mode;\n  }\n\n  /**\n   * Restore the previous tokenizer mode if one exists on the stack.\n   */\n  private popMode(): void {\n    if (this.modeStack.length > 0) {\n      this.mode = this.modeStack.pop()!;\n    }\n  }\n\n  // ========================================================================\n  // Helper methods\n  // ========================================================================\n\n  /**\n   * Peek at the current character without consuming it.\n   *\n   * @returns The current character or empty string when at EOF.\n   */\n  private peek(): string {\n    if (this.index >= this.input.length) {\n      return \"\";\n    }\n    return this.input[this.index];\n  }\n\n  /**\n   * Peek ahead by one character without consuming it.\n   *\n   * @returns The next character or empty string when beyond EOF.\n   */\n  private peekNext(): string {\n    if (this.index + 1 >= this.input.length) {\n      return \"\";\n    }\n    return this.input[this.index + 1];\n  }\n\n  /**\n   * Move forward by one character, updating column tracking.\n   */\n  private advance(): void {\n    if (this.index < this.input.length) {\n      this.index++;\n      this.column++;\n    }\n  }\n\n  /**\n   * Capture the current cursor position.\n   *\n   * @returns The current `Position` snapshot.\n   */\n  private getPosition(): Position {\n    return {\n      line: this.line,\n      column: this.column,\n      index: this.index,\n    };\n  }\n\n  /**\n   * Build a token using the provided metadata.\n   * v2.1: Includes modeAtToken, rawIndex, and optional isPotentialLayoutStart.\n   *\n   * @param type - Token type identifier.\n   * @param value - Raw lexeme value.\n   * @param start - Starting position (inclusive).\n   * @param end - Ending position (exclusive).\n   * @param isPotentialLayoutStart - Optional flag for \"layout\" identifier.\n   * @returns Constructed token object.\n   */\n  private createToken(\n    type: TokenType,\n    value: string,\n    start: Position,\n    end: Position,\n    isPotentialLayoutStart?: boolean\n  ): Token {\n    const token: Token = {\n      type,\n      value,\n      range: { start, end },\n      modeAtToken: this.mode, // v2.1: Record mode when token was created\n      rawIndex: start.index, // v2.1: Original index in source\n    };\n\n    // Add optional flag if provided\n    if (isPotentialLayoutStart) {\n      token.isPotentialLayoutStart = true;\n    }\n\n    return token;\n  }\n\n  /**\n   * Produce a normalized tokenizer error with consistent messaging.\n   *\n   * @param message - Human readable error detail.\n   * @param position - Location where the error occurred.\n   * @returns Error instance ready to be thrown.\n   */\n  private createError(message: string, position: Position): Error {\n    return new Error(\n      `Tokenizer Error at line ${position.line}, column ${position.column}: ${message}`\n    );\n  }\n\n  // ========================================================================\n  // Character classification helpers\n  // ========================================================================\n\n  /**\n   * Check whether the provided character is alphabetic.\n   *\n   * @param char - Character to check.\n   * @returns `true` when the character is within `[a-zA-Z]`.\n   */\n  private isLetter(char: string): boolean {\n    return /[a-zA-Z]/.test(char);\n  }\n\n  /**\n   * Check whether the provided character is numeric.\n   *\n   * @param char - Character to check.\n   * @returns `true` when the character is within `[0-9]`.\n   */\n  private isDigit(char: string): boolean {\n    return /[0-9]/.test(char);\n  }\n\n  /**\n   * Determine if the character is uppercase alphabetic.\n   *\n   * @param char - Character to check.\n   * @returns `true` when the character is within `[A-Z]`.\n   */\n  private isUpperCase(char: string): boolean {\n    return /[A-Z]/.test(char);\n  }\n\n  /**\n   * Determine if the character is lowercase alphabetic.\n   *\n   * @param char - Character to check.\n   * @returns `true` when the character is within `[a-z]`.\n   */\n  private isLowerCase(char: string): boolean {\n    return /[a-z]/.test(char);\n  }\n\n  /**\n   * Evaluate whether a character is forbidden by the DSL spec.\n   *\n   * v2.1 Backslash handling:\n   * - Outside strings (NORMAL/ATTRIBUTES mode): backslash is FORBIDDEN\n   * - Inside strings (STRING_LITERAL mode): backslash is ALLOWED for escape sequences\n   * - This is enforced by mode check in nextToken() before calling this function\n   * - See nextToken() line 120: `if (this.mode !== TokenizerMode.STRING_LITERAL && ...)`\n   *\n   * Why backslash is forbidden outside strings:\n   * - Prevents confusion with escape sequences\n   * - Keeps syntax unambiguous\n   * - Forces explicit string literals for special characters\n   *\n   * Forbidden characters (from README):\n   * - ; (semicolon)     - prevents statement separation confusion\n   * - ' (single quote)  - enforces double-quote strings only\n   * - ` (backtick)      - prevents template literal confusion\n   * - @ (at sign)       - reserved for future decorators\n   * - # (hash)          - reserved for future directives\n   * - $ (dollar)        - reserved for future template syntax\n   * - % (percent)       - prevents modulo confusion\n   * - ^ (caret)         - prevents XOR confusion\n   * - & (ampersand)     - prevents AND confusion\n   * - * (asterisk)      - prevents multiplication confusion\n   * - = (equals)        - enforces colon for assignment\n   * - + (plus)          - prevents addition confusion\n   * - | (pipe)          - prevents OR confusion\n   * - \\ (backslash)     - forbidden outside strings (see above)\n   * - < (less than)     - prevents comparison confusion\n   * - > (greater than)  - prevents comparison confusion\n   * - ? (question mark) - prevents ternary confusion\n   * - ~ (tilde)         - prevents NOT confusion\n   * - \\t (tab)          - checked in constructor\n   * - \\r\\n (CRLF)       - checked in constructor\n   *\n   * @param char - Character to check.\n   * @returns `true` when the character should trigger an error.\n   */\n  private isForbiddenChar(char: string): boolean {\n    const forbidden = [\n      \";\",  // semicolon\n      \"'\",  // single quote\n      \"`\",  // backtick\n      \"@\",  // at sign\n      \"#\",  // hash\n      \"$\",  // dollar\n      \"%\",  // percent\n      \"^\",  // caret\n      \"&\",  // ampersand\n      \"*\",  // asterisk\n      \"=\",  // equals\n      \"+\",  // plus\n      \"|\",  // pipe\n      \"\\\\\", // backslash (forbidden outside strings, allowed inside for \\\")\n      \"<\",  // less than\n      \">\",  // greater than\n      \"?\",  // question mark\n      \"~\",  // tilde\n    ];\n    return forbidden.includes(char);\n  }\n}\n\n// Export main tokenize function\n/**\n * Convenience wrapper that tokenizes the provided DSL source text.\n *\n * @param input - Raw DSL source text.\n * @returns Token list produced by `Tokenizer`.\n */\nexport function tokenize(input: string): Token[] {\n  const tokenizer = new Tokenizer(input);\n  return tokenizer.tokenize();\n}\n","/**\n * UIH DSL Parser v2 - Error Collection & Recovery\n *\n * Transforms token stream from Tokenizer v2.1 into AST with error collection.\n *\n * Design principles:\n * - No throw statements (collect all errors)\n * - Error recovery at NEWLINE, RBRACE, EOF\n * - Partial AST generation (best effort)\n * - Multiple error reporting\n *\n * @module @parser/parser\n * @version 2.0.0\n */\n\nimport type { Token, Range } from \"@uih-dsl/tokenizer\";\nimport { TokenType, TokenizerMode } from \"@uih-dsl/tokenizer\";\nimport type {\n  ASTRoot,\n  MetaNode,\n  MetaProperty,\n  StyleNode,\n  StyleProperty,\n  ComponentsNode,\n  ComponentEntry,\n  LayoutNode,\n  LayoutElement,\n  LayoutComponent,\n  LayoutText,\n  Attribute,\n  ScriptNode,\n  ScriptProperty,\n} from \"./ast.js\";\n\n/**\n * Parser error information.\n */\nexport interface ParserError {\n  message: string;\n  line: number;\n  column: number;\n}\n\n/**\n * Parse result containing AST and errors.\n */\nexport interface ParseResult {\n  ast: ASTRoot | null;\n  errors: ParserError[];\n}\n\n/**\n * Parser class for UIH DSL v2.\n *\n * Implements error collection and recovery mechanisms.\n *\n * @public\n */\nexport class Parser {\n  private tokens: Token[];\n  private current: number = 0;\n  private errors: ParserError[] = [];\n\n  /**\n   * Create a new parser instance.\n   *\n   * @param tokens - Token stream from Tokenizer v2.1\n   */\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n  }\n\n  // ========================================================================\n  // Main Entry Point\n  // ========================================================================\n\n  /**\n   * Parse the complete token stream into an AST with error collection.\n   *\n   * @returns ParseResult with AST and errors\n   */\n  public parseFile(): ParseResult {\n    this.errors = [];\n    this.current = 0;\n\n    this.skipNewlines();\n\n    const meta = this.parseBlock(\"meta\") as MetaNode | null;\n    const style = this.parseBlock(\"style\") as StyleNode | null;\n    const components = this.parseBlock(\"components\") as ComponentsNode | null;\n    const layout = this.parseBlock(\"layout\") as LayoutNode | null;\n    const script = this.parseBlock(\"script\") as ScriptNode | null;\n\n    if (!layout) {\n      this.recordError(\"Layout block is required\", this.peek().range.start);\n    }\n\n    const finalMeta: MetaNode = meta || {\n      type: \"Meta\",\n      properties: [],\n    };\n\n    const finalStyle: StyleNode = style || {\n      type: \"Style\",\n      properties: [],\n    };\n\n    this.skipNewlines();\n    if (!this.isAtEnd()) {\n      this.recordError(\n        `Unexpected token after script block: ${this.peek().value}`,\n        this.peek().range.start\n      );\n      this.skipUntilRecoveryPoint();\n    }\n\n    const ast: ASTRoot | null = layout\n      ? {\n          type: \"Program\",\n          meta: finalMeta,\n          style: finalStyle,\n          components,\n          layout,\n          script,\n        }\n      : null;\n\n    return {\n      ast,\n      errors: this.errors,\n    };\n  }\n\n  // ========================================================================\n  // Block Parsing\n  // ========================================================================\n\n  /**\n   * Parse a top-level block with error recovery.\n   *\n   * @param expectedBlockName - Expected block identifier\n   * @returns Parsed block node or null if failed\n   */\n  private parseBlock(\n    expectedBlockName: string\n  ): MetaNode | StyleNode | ComponentsNode | LayoutNode | ScriptNode | null {\n    this.skipNewlines();\n\n    const token = this.peek();\n\n    if (token.type !== TokenType.IDENTIFIER || token.value !== expectedBlockName) {\n      return null;\n    }\n\n    if (expectedBlockName === \"layout\" && !token.isPotentialLayoutStart) {\n      return null;\n    }\n\n    this.consume();\n\n    this.skipNewlines();\n    if (!this.match(TokenType.LBRACE)) {\n      this.recordError(`Expected LBRACE after ${expectedBlockName}`, this.peek().range.start);\n      this.skipUntilRecoveryPoint();\n      return null;\n    }\n    this.consume();\n    this.skipNewlines();\n\n    let result:\n      | MetaNode\n      | StyleNode\n      | ComponentsNode\n      | LayoutNode\n      | ScriptNode\n      | null = null;\n\n    try {\n      switch (expectedBlockName) {\n        case \"meta\":\n          result = this.parseMeta();\n          break;\n        case \"style\":\n          result = this.parseStyle();\n          break;\n        case \"components\":\n          result = this.parseComponents();\n          break;\n        case \"layout\":\n          result = this.parseLayout();\n          break;\n        case \"script\":\n          result = this.parseScript();\n          break;\n        default:\n          this.recordError(`Unknown block type: ${expectedBlockName}`, token.range.start);\n          this.skipUntilRecoveryPoint();\n          return null;\n      }\n    } catch (e) {\n      this.skipUntilRecoveryPoint();\n      return null;\n    }\n\n    this.skipNewlines();\n    if (!this.match(TokenType.RBRACE)) {\n      this.recordError(`Expected RBRACE to close ${expectedBlockName} block`, this.peek().range.start);\n      this.skipUntilRecoveryPoint();\n    } else {\n      this.consume();\n    }\n    this.skipNewlines();\n\n    return result;\n  }\n\n  /**\n   * Parse meta block content with error recovery.\n   *\n   * @returns MetaNode\n   */\n  private parseMeta(): MetaNode {\n    const properties: MetaProperty[] = [];\n\n    while (!this.match(TokenType.RBRACE) && !this.isAtEnd()) {\n      this.skipNewlines();\n\n      if (this.match(TokenType.RBRACE)) {\n        break;\n      }\n\n      if (!this.match(TokenType.IDENTIFIER)) {\n        this.recordError(\"Expected property key (IDENTIFIER)\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const keyToken = this.consume();\n\n      if (!this.match(TokenType.COLON)) {\n        this.recordError(\"Expected COLON after property key\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n      this.consume();\n\n      const value = this.parseLiteral();\n      if (value === null) {\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const location: Range = {\n        start: keyToken.range.start,\n        end: this.tokens[this.current - 1].range.end,\n      };\n\n      properties.push({\n        key: keyToken.value,\n        value,\n        location,\n      });\n\n      this.skipNewlines();\n    }\n\n    return {\n      type: \"Meta\",\n      properties,\n    };\n  }\n\n  /**\n   * Parse style block content with error recovery.\n   *\n   * @returns StyleNode\n   */\n  private parseStyle(): StyleNode {\n    const properties: StyleProperty[] = [];\n\n    while (!this.match(TokenType.RBRACE) && !this.isAtEnd()) {\n      this.skipNewlines();\n\n      if (this.match(TokenType.RBRACE)) {\n        break;\n      }\n\n      if (!this.match(TokenType.IDENTIFIER)) {\n        this.recordError(\"Expected style key (IDENTIFIER)\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const keyToken = this.consume();\n\n      if (!this.match(TokenType.COLON)) {\n        this.recordError(\"Expected COLON after style key\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n      this.consume();\n\n      const value = this.parseLiteral();\n      if (value === null) {\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      if (typeof value === \"boolean\") {\n        this.recordError(\"Style values cannot be boolean\", keyToken.range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const location: Range = {\n        start: keyToken.range.start,\n        end: this.tokens[this.current - 1].range.end,\n      };\n\n      properties.push({\n        key: keyToken.value,\n        value,\n        location,\n      });\n\n      this.skipNewlines();\n    }\n\n    return {\n      type: \"Style\",\n      properties,\n    };\n  }\n\n  /**\n   * Parse components block content with error recovery.\n   *\n   * @returns ComponentsNode\n   */\n  private parseComponents(): ComponentsNode {\n    const components: ComponentEntry[] = [];\n\n    while (!this.match(TokenType.RBRACE) && !this.isAtEnd()) {\n      this.skipNewlines();\n\n      if (this.match(TokenType.RBRACE)) {\n        break;\n      }\n\n      if (!this.match(TokenType.TAGNAME)) {\n        this.recordError(\"Expected component name (TAGNAME)\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const nameToken = this.consume();\n\n      components.push({\n        name: nameToken.value,\n        location: nameToken.range,\n      });\n\n      this.skipNewlines();\n    }\n\n    return {\n      type: \"Components\",\n      components,\n    };\n  }\n\n  /**\n   * Parse layout block content with error recovery.\n   *\n   * @returns LayoutNode\n   */\n  private parseLayout(): LayoutNode {\n    const children = this.parseComponentTree();\n\n    return {\n      type: \"Layout\",\n      children,\n    };\n  }\n\n  /**\n   * Parse script block content with error recovery.\n   *\n   * @returns ScriptNode\n   */\n  private parseScript(): ScriptNode {\n    const events: ScriptProperty[] = [];\n\n    while (!this.match(TokenType.RBRACE) && !this.isAtEnd()) {\n      this.skipNewlines();\n\n      if (this.match(TokenType.RBRACE)) {\n        break;\n      }\n\n      if (!this.match(TokenType.IDENTIFIER)) {\n        this.recordError(\"Expected event key (IDENTIFIER)\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const keyToken = this.consume();\n\n      if (!this.match(TokenType.COLON)) {\n        this.recordError(\"Expected COLON after event key\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n      this.consume();\n\n      if (!this.match(TokenType.STRING)) {\n        this.recordError(\"Expected STRING for event value\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        continue;\n      }\n\n      const valueToken = this.consume();\n\n      const location: Range = {\n        start: keyToken.range.start,\n        end: valueToken.range.end,\n      };\n\n      events.push({\n        key: keyToken.value,\n        value: valueToken.value,\n        location,\n      });\n\n      this.skipNewlines();\n    }\n\n    return {\n      type: \"Script\",\n      events,\n    };\n  }\n\n  // ========================================================================\n  // Layout Tree Parsing\n  // ========================================================================\n\n  /**\n   * Parse a component tree with error recovery.\n   *\n   * @returns Array of LayoutElements\n   */\n  private parseComponentTree(): LayoutElement[] {\n    const elements: LayoutElement[] = [];\n\n    while (!this.match(TokenType.RBRACE) && !this.isAtEnd()) {\n      this.skipNewlines();\n\n      if (this.match(TokenType.RBRACE)) {\n        break;\n      }\n\n      const element = this.parseElement();\n      if (element) {\n        elements.push(element);\n      }\n\n      this.skipNewlines();\n    }\n\n    return elements;\n  }\n\n  /**\n   * Parse a single layout element with error recovery.\n   *\n   * @returns LayoutElement or null\n   */\n  private parseElement(): LayoutElement | null {\n    const token = this.peek();\n\n    if (this.isTextString(token)) {\n      return this.parseText();\n    }\n\n    if (token.type === TokenType.TAGNAME) {\n      return this.parseComponent();\n    }\n\n    this.recordError(`Expected component or text, got ${token.type}`, token.range.start);\n    this.skipUntilRecoveryPoint();\n    return null;\n  }\n\n  /**\n   * Parse a text node with error recovery.\n   *\n   * @returns LayoutText or null\n   */\n  private parseText(): LayoutText | null {\n    if (!this.match(TokenType.STRING)) {\n      this.recordError(\"Expected STRING for text node\", this.peek().range.start);\n      return null;\n    }\n\n    const token = this.consume();\n\n    return {\n      type: \"Text\",\n      value: token.value,\n      location: token.range,\n    };\n  }\n\n  /**\n   * Parse a component node with error recovery.\n   *\n   * @returns LayoutComponent or null\n   */\n  private parseComponent(): LayoutComponent | null {\n    if (!this.match(TokenType.TAGNAME)) {\n      this.recordError(\"Expected TAGNAME for component\", this.peek().range.start);\n      return null;\n    }\n\n    const tagToken = this.consume();\n    const tag = tagToken.value;\n\n    let attributes: Attribute[] = [];\n    if (this.match(TokenType.LPAREN)) {\n      this.consume();\n      attributes = this.parseAttributes();\n      if (!this.match(TokenType.RPAREN)) {\n        this.recordError(\"Expected RPAREN after attributes\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n      } else {\n        this.consume();\n      }\n    }\n\n    let children: LayoutElement[] = [];\n    this.skipNewlines();\n\n    if (this.match(TokenType.LBRACE)) {\n      this.consume();\n      this.skipNewlines();\n      children = this.parseComponentTree();\n      if (!this.match(TokenType.RBRACE)) {\n        this.recordError(\"Expected RBRACE to close component\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n      } else {\n        this.consume();\n      }\n    }\n\n    const location: Range = {\n      start: tagToken.range.start,\n      end: this.tokens[this.current - 1].range.end,\n    };\n\n    return {\n      type: \"Component\",\n      tag,\n      attributes,\n      children,\n      location,\n    };\n  }\n\n  // ========================================================================\n  // Helper Parsing Functions\n  // ========================================================================\n\n  /**\n   * Parse component attributes with error recovery.\n   *\n   * @returns Array of Attributes\n   */\n  private parseAttributes(): Attribute[] {\n    const attributes: Attribute[] = [];\n\n    while (!this.match(TokenType.RPAREN) && !this.isAtEnd()) {\n      if (!this.match(TokenType.IDENTIFIER)) {\n        this.recordError(\"Expected attribute key (IDENTIFIER)\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        break;\n      }\n\n      const keyToken = this.consume();\n\n      if (!this.match(TokenType.COLON)) {\n        this.recordError(\"Expected COLON after attribute key\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        break;\n      }\n      this.consume();\n\n      if (!this.match(TokenType.STRING)) {\n        this.recordError(\"Expected STRING for attribute value\", this.peek().range.start);\n        this.skipUntilRecoveryPoint();\n        break;\n      }\n\n      const valueToken = this.consume();\n\n      const location: Range = {\n        start: keyToken.range.start,\n        end: valueToken.range.end,\n      };\n\n      attributes.push({\n        key: keyToken.value,\n        value: valueToken.value,\n        location,\n      });\n\n      if (this.match(TokenType.COMMA)) {\n        this.consume();\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Parse a literal value with error recovery.\n   *\n   * @returns string | number | boolean | null\n   */\n  private parseLiteral(): string | number | boolean | null {\n    const token = this.peek();\n\n    if (token.type === TokenType.STRING) {\n      this.consume();\n      return token.value;\n    }\n\n    if (token.type === TokenType.NUMBER) {\n      this.consume();\n      return parseFloat(token.value);\n    }\n\n    if (token.type === TokenType.BOOLEAN) {\n      this.consume();\n      return token.value === \"true\";\n    }\n\n    this.recordError(`Expected literal value, got ${token.type}`, token.range.start);\n    return null;\n  }\n\n  // ========================================================================\n  // TEXT_STRING Determination\n  // ========================================================================\n\n  /**\n   * Determine if a token is a TEXT_STRING.\n   *\n   * @param token - Token to check\n   * @returns true if token is TEXT_STRING\n   */\n  private isTextString(token: Token): boolean {\n    if (token.type !== TokenType.STRING) {\n      return false;\n    }\n\n    if (token.modeAtToken === TokenizerMode.ATTRIBUTES) {\n      return false;\n    }\n\n    const prevToken = this.getPreviousNonNewlineToken();\n\n    return prevToken !== null && prevToken.type === TokenType.LBRACE;\n  }\n\n  /**\n   * Get the previous non-newline token.\n   *\n   * @returns Previous non-newline token or null\n   */\n  private getPreviousNonNewlineToken(): Token | null {\n    for (let i = this.current - 1; i >= 0; i--) {\n      if (this.tokens[i].type !== TokenType.NEWLINE) {\n        return this.tokens[i];\n      }\n    }\n    return null;\n  }\n\n  // ========================================================================\n  // Token Access Functions\n  // ========================================================================\n\n  /**\n   * Peek at the current token without consuming it.\n   *\n   * @returns Current token\n   */\n  private peek(): Token {\n    return this.tokens[this.current];\n  }\n\n  /**\n   * Consume the current token and move to the next.\n   *\n   * @returns The consumed token\n   */\n  private consume(): Token {\n    const token = this.tokens[this.current];\n    this.current++;\n    return token;\n  }\n\n  /**\n   * Check if the current token matches any of the given types.\n   *\n   * @param types - Token types to match\n   * @returns true if current token matches any type\n   */\n  private match(...types: TokenType[]): boolean {\n    const token = this.peek();\n    return types.includes(token.type);\n  }\n\n  /**\n   * Check if we've reached the end of the token stream.\n   *\n   * @returns true if at EOF\n   */\n  private isAtEnd(): boolean {\n    return this.peek().type === TokenType.EOF;\n  }\n\n  /**\n   * Skip consecutive newline tokens.\n   */\n  private skipNewlines(): void {\n    while (this.match(TokenType.NEWLINE)) {\n      this.consume();\n    }\n  }\n\n  // ========================================================================\n  // Error Handling & Recovery\n  // ========================================================================\n\n  /**\n   * Record a parser error without throwing.\n   *\n   * @param message - Error message\n   * @param position - Location where error occurred\n   */\n  private recordError(message: string, position: { line: number; column: number }): void {\n    this.errors.push({\n      message,\n      line: position.line,\n      column: position.column,\n    });\n  }\n\n  /**\n   * Skip tokens until recovery point.\n   *\n   * Recovery points: NEWLINE, RBRACE, EOF\n   */\n  private skipUntilRecoveryPoint(): void {\n    while (!this.isAtEnd()) {\n      const token = this.peek();\n      if (token.type === TokenType.NEWLINE || token.type === TokenType.RBRACE || token.type === TokenType.EOF) {\n        break;\n      }\n      this.consume();\n    }\n  }\n}\n\n// ========================================================================\n// Export Convenience Function\n// ========================================================================\n\n/**\n * Parse a token stream into an AST with error collection.\n *\n * @param tokens - Token stream from Tokenizer\n * @returns ParseResult with AST and errors\n */\nexport function parse(tokens: Token[]): ParseResult {\n  const parser = new Parser(tokens);\n  return parser.parseFile();\n}\n","/**\n * UIH DSL IR Normalization Utilities\n *\n * Provides utility functions for normalizing AST nodes into IR format.\n * All functions are pure and deterministic.\n *\n * @module @uih-dsl/ir/normalize\n * @version 1.0.0\n */\n\nimport type { Attribute } from \"@uih-dsl/parser\";\nimport type { IRError } from \"./types.js\";\n\n// ========================================================================\n// Attribute Normalization\n// ========================================================================\n\n/**\n * Normalize AST attributes to IR format.\n * Sorts by key for deterministic output.\n *\n * @param attrs - AST attribute array\n * @returns Normalized and sorted attribute array\n */\nexport function normalizeAttributes(\n  attrs: Attribute[]\n): Array<{ key: string; value: string }> {\n  return attrs\n    .map((attr) => ({\n      key: attr.key,\n      value: attr.value,\n    }))\n    .sort((a, b) => a.key.localeCompare(b.key));\n}\n\n// ========================================================================\n// Style Path Normalization\n// ========================================================================\n\n/**\n * Split dot-notation style key into path array.\n *\n * @param key - Style key with dot notation (e.g., \"color.primary\")\n * @returns Path array (e.g., [\"color\", \"primary\"])\n *\n * @example\n * ```typescript\n * splitStylePath(\"color.primary\") // [\"color\", \"primary\"]\n * splitStylePath(\"font.size\") // [\"font\", \"size\"]\n * ```\n */\nexport function splitStylePath(key: string): string[] {\n  return key.split(\".\");\n}\n\n/**\n * Validate that style path has at least 2 segments.\n *\n * @param path - Style path array\n * @returns True if valid (length >= 2)\n */\nexport function isValidStylePath(path: string[]): boolean {\n  return path.length >= 2;\n}\n\n// ========================================================================\n// Object Key Sorting\n// ========================================================================\n\n/**\n * Sort object keys alphabetically.\n * Creates a new object with sorted keys for deterministic output.\n *\n * @param obj - Input object\n * @returns New object with sorted keys\n */\nexport function sortObjectKeys<T extends Record<string, unknown>>(obj: T): T {\n  const sorted = {} as T;\n  const keys = Object.keys(obj).sort();\n\n  for (const key of keys) {\n    sorted[key as keyof T] = obj[key as keyof T];\n  }\n\n  return sorted;\n}\n\n// ========================================================================\n// Error Collection\n// ========================================================================\n\n/**\n * Push an error to the error array.\n * Helper for error collection during translation.\n *\n * @param errors - Error array to append to\n * @param message - Error message\n * @param location - Source location\n */\nexport function pushError(\n  errors: IRError[],\n  message: string,\n  location: { line: number; column: number }\n): void {\n  errors.push({\n    message,\n    line: location.line,\n    column: location.column,\n  });\n}\n\n// ========================================================================\n// Script Key Validation\n// ========================================================================\n\n/**\n * Validate that script event key is in camelCase format.\n * Accepts lowercase keys (tokenizer limitation).\n *\n * @param key - Script event key\n * @returns True if valid camelCase or lowercase\n */\nexport function isValidScriptKey(key: string): boolean {\n  // Accept camelCase or all lowercase (tokenizer limitation)\n  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n  return camelCaseRegex.test(key);\n}\n\n/**\n * Check if script value is empty (after trimming).\n *\n * @param value - Script handler value\n * @returns True if empty\n */\nexport function isEmptyScriptValue(value: string): boolean {\n  return value.trim() === \"\";\n}\n\n// ========================================================================\n// Array Stability\n// ========================================================================\n\n/**\n * Sort string array alphabetically for deterministic output.\n *\n * @param arr - Input string array\n * @returns New sorted array\n */\nexport function sortStringArray(arr: string[]): string[] {\n  return [...arr].sort();\n}\n\n/**\n * Sort style tokens by path for deterministic output.\n * Compares path arrays lexicographically.\n *\n * @param tokens - Style token array\n * @returns New sorted token array\n */\nexport function sortStyleTokens<T extends { path: string[] }>(tokens: T[]): T[] {\n  return [...tokens].sort((a, b) => {\n    const pathA = a.path.join(\".\");\n    const pathB = b.path.join(\".\");\n    return pathA.localeCompare(pathB);\n  });\n}\n\n/**\n * Sort script entries by event name for deterministic output.\n *\n * @param entries - Script entry array\n * @returns New sorted entry array\n */\nexport function sortScriptEntries<T extends { event: string }>(entries: T[]): T[] {\n  return [...entries].sort((a, b) => a.event.localeCompare(b.event));\n}\n","/**\n * UIH DSL IR Translator\n *\n * Transforms UIH AST into normalized IR structure.\n * Uses error collection instead of throwing exceptions.\n *\n * @module @uih-dsl/ir/translator\n * @version 1.0.0\n */\n\nimport type {\n  ASTRoot,\n  MetaNode,\n  StyleNode,\n  ComponentsNode,\n  LayoutNode,\n  LayoutElement,\n  LayoutComponent,\n  LayoutText,\n  ScriptNode,\n  ParserError,\n} from \"@uih-dsl/parser\";\nimport type { UIHIR, IRNode, IRError, StyleToken, ScriptEntry } from \"./types.js\";\nimport {\n  normalizeAttributes,\n  splitStylePath,\n  isValidStylePath,\n  sortObjectKeys,\n  pushError,\n  isValidScriptKey,\n  isEmptyScriptValue,\n  sortStringArray,\n  sortStyleTokens,\n  sortScriptEntries,\n} from \"./normalize.js\";\n\n// ========================================================================\n// Main IR Creation\n// ========================================================================\n\n/**\n * Create IR from AST.\n * Combines parser errors with translation errors.\n *\n * @param ast - Root AST node (can be null if parser failed completely)\n * @param parserErrors - Errors from parser\n * @returns Complete UIHIR structure\n */\nexport function createIR(ast: ASTRoot | null, parserErrors: ParserError[]): UIHIR {\n  const translationErrors: IRError[] = [];\n\n  // Convert parser errors to IR errors\n  const errors: IRError[] = parserErrors.map((err) => ({\n    message: err.message,\n    line: err.line,\n    column: err.column,\n  }));\n\n  // If AST is null, return minimal IR with errors\n  if (ast === null) {\n    return {\n      meta: {},\n      style: { tokens: [] },\n      components: [],\n      layout: [],\n      script: [],\n      errors,\n    };\n  }\n\n  // Transform each block\n  const meta = createMetaIR(ast.meta, translationErrors);\n  const style = createStyleIR(ast.style, translationErrors);\n  const components = createComponentsIR(ast.components);\n  const layout = createLayoutIR(ast.layout);\n  const script = createScriptIR(ast.script, translationErrors);\n\n  // Combine all errors\n  const allErrors = [...errors, ...translationErrors];\n\n  return {\n    meta,\n    style,\n    components,\n    layout,\n    script,\n    errors: allErrors,\n  };\n}\n\n// ========================================================================\n// Meta Block Translation\n// ========================================================================\n\n/**\n * Create meta IR from MetaNode.\n * Flattens properties into a key-value object.\n * Sorts keys alphabetically for deterministic output.\n *\n * @param node - Meta AST node\n * @param errors - Error collection array\n * @returns Meta object with sorted keys\n */\nfunction createMetaIR(\n  node: MetaNode,\n  errors: IRError[]\n): Record<string, string | number | boolean> {\n  const meta: Record<string, string | number | boolean> = {};\n\n  for (const prop of node.properties) {\n    // Validate value type (should be string, number, or boolean)\n    if (\n      typeof prop.value === \"string\" ||\n      typeof prop.value === \"number\" ||\n      typeof prop.value === \"boolean\"\n    ) {\n      meta[prop.key] = prop.value;\n    } else {\n      pushError(\n        errors,\n        `Meta property '${prop.key}' has invalid value type`,\n        prop.location.start\n      );\n    }\n  }\n\n  // Sort keys alphabetically for deterministic output\n  return sortObjectKeys(meta);\n}\n\n// ========================================================================\n// Style Block Translation\n// ========================================================================\n\n/**\n * Create style IR from StyleNode.\n * Splits dot-notation keys into path arrays.\n * Rejects boolean values.\n * Sorts tokens by path for deterministic output.\n *\n * @param node - Style AST node\n * @param errors - Error collection array\n * @returns Style object with token array\n */\nfunction createStyleIR(node: StyleNode, errors: IRError[]): { tokens: StyleToken[] } {\n  const tokens: StyleToken[] = [];\n\n  for (const prop of node.properties) {\n    // Validate value type (must be string or number, not boolean)\n    if (typeof prop.value === \"boolean\") {\n      pushError(\n        errors,\n        `Style property '${prop.key}' cannot have boolean value`,\n        prop.location.start\n      );\n      continue;\n    }\n\n    // Split path\n    const path = splitStylePath(prop.key);\n\n    // Validate path (must have at least 2 segments)\n    if (!isValidStylePath(path)) {\n      pushError(\n        errors,\n        `Style key '${prop.key}' must use dot notation (e.g., 'color.primary')`,\n        prop.location.start\n      );\n      continue;\n    }\n\n    tokens.push({\n      path,\n      value: prop.value,\n    });\n  }\n\n  // Sort tokens for deterministic output\n  const sortedTokens = sortStyleTokens(tokens);\n\n  return { tokens: sortedTokens };\n}\n\n// ========================================================================\n// Components Block Translation\n// ========================================================================\n\n/**\n * Create components IR from ComponentsNode.\n * Extracts component names.\n * Sorts alphabetically for deterministic output.\n *\n * @param node - Components AST node (optional)\n * @returns Array of component names\n */\nfunction createComponentsIR(node: ComponentsNode | null): string[] {\n  if (!node) {\n    return [];\n  }\n\n  const names = node.components.map((comp) => comp.name);\n\n  // Sort for deterministic output\n  return sortStringArray(names);\n}\n\n// ========================================================================\n// Layout Block Translation\n// ========================================================================\n\n/**\n * Create layout IR from LayoutNode.\n * Recursively transforms layout tree.\n *\n * @param node - Layout AST node\n * @returns Array of IR nodes\n */\nfunction createLayoutIR(node: LayoutNode): IRNode[] {\n  return node.children.map((child) => transformLayoutElement(child));\n}\n\n/**\n * Transform a layout element (component or text) to IR.\n *\n * @param node - Layout element AST node\n * @returns IR node (component or text)\n */\nfunction transformLayoutElement(node: LayoutElement): IRNode {\n  if (node.type === \"Component\") {\n    return transformLayoutComponent(node);\n  } else {\n    return transformLayoutText(node);\n  }\n}\n\n/**\n * Transform a layout component to IR.\n * Normalizes attributes and recursively transforms children.\n *\n * @param node - Layout component AST node\n * @returns IR component node\n */\nfunction transformLayoutComponent(node: LayoutComponent): IRNode {\n  // Normalize and sort attributes\n  const attrs = normalizeAttributes(node.attributes);\n\n  // Recursively transform children\n  const children = node.children.map((child) => transformLayoutElement(child));\n\n  return {\n    type: \"Component\",\n    tag: node.tag,\n    attrs,\n    children,\n  };\n}\n\n/**\n * Transform a layout text node to IR.\n *\n * @param node - Layout text AST node\n * @returns IR text node\n */\nfunction transformLayoutText(node: LayoutText): IRNode {\n  return {\n    type: \"Text\",\n    value: node.value,\n  };\n}\n\n// ========================================================================\n// Script Block Translation\n// ========================================================================\n\n/**\n * Create script IR from ScriptNode.\n * Validates event keys and handler values.\n * Sorts by event name for deterministic output.\n *\n * @param node - Script AST node (optional)\n * @param errors - Error collection array\n * @returns Array of script entries\n */\nfunction createScriptIR(node: ScriptNode | null, errors: IRError[]): ScriptEntry[] {\n  if (!node) {\n    return [];\n  }\n\n  const entries: ScriptEntry[] = [];\n\n  for (const event of node.events) {\n    // Validate key format\n    if (!isValidScriptKey(event.key)) {\n      pushError(\n        errors,\n        `Script key '${event.key}' must be in camelCase format`,\n        event.location.start\n      );\n      continue;\n    }\n\n    // Validate value is not empty\n    if (isEmptyScriptValue(event.value)) {\n      pushError(\n        errors,\n        `Script handler for '${event.key}' cannot be empty`,\n        event.location.start\n      );\n      continue;\n    }\n\n    entries.push({\n      event: event.key,\n      handler: event.value,\n    });\n  }\n\n  // Sort for deterministic output\n  return sortScriptEntries(entries);\n}\n","/**\n * UIH DSL Codegen - Meta Generator\n *\n * Generates Next.js metadata from IR meta block.\n *\n * @module @uih-dsl/codegen-react/meta\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function generateMeta(ir: UIHIR): string | null {\n  const keys = Object.keys(ir.meta);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  const entries = keys.map((key) => {\n    const value = ir.meta[key];\n    const formattedValue = formatMetaValue(value);\n    return `  ${key}: ${formattedValue}`;\n  });\n\n  return `export const metadata = {\n${entries.join(\",\\n\")}\n};`;\n}\n\nfunction formatMetaValue(value: string | number | boolean): string {\n  if (typeof value === \"string\") {\n    return `\"${escapeString(value)}\"`;\n  }\n  return String(value);\n}\n\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/\\t/g, \"\\\\t\");\n}\n","/**\n * UIH DSL Codegen - Style Generator\n *\n * Generates CSS variables from IR style tokens.\n *\n * @module @uih-dsl/codegen-react/style\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\n// ========================================================================\n// CSS Variable Generation\n// ========================================================================\n\n/**\n * Generate CSS variables from IR style tokens.\n * Converts path arrays to CSS variable names with dash notation.\n *\n * @param ir - UIH IR structure\n * @returns CSS string with :root block, or null if no tokens\n *\n * @example\n * ```typescript\n * // Input: { path: [\"color\", \"primary\"], value: \"#0E5EF7\" }\n * // Output: --color-primary: #0E5EF7;\n * ```\n */\nexport function generateStyle(ir: UIHIR): string | null {\n  if (ir.style.tokens.length === 0) {\n    return null;\n  }\n\n  const variables = ir.style.tokens.map((token) => {\n    const varName = token.path.join(\"-\");\n    const value = formatStyleValue(token.value);\n    return `  --${varName}: ${value};`;\n  });\n\n  return `:root {\\n${variables.join(\"\\n\")}\\n}`;\n}\n\n/**\n * Format style value for CSS output.\n * Numbers without units are kept as-is.\n *\n * @param value - Style token value\n * @returns Formatted CSS value\n */\nfunction formatStyleValue(value: string | number): string {\n  if (typeof value === \"number\") {\n    return String(value);\n  }\n  return value;\n}\n\n/**\n * Generate inline style tag for React component.\n *\n * @param styleString - CSS string\n * @returns Style tag code\n */\nexport function generateStyleTag(styleString: string | null): string | null {\n  if (!styleString) {\n    return null;\n  }\n\n  return `<style jsx global>{\\`\n${styleString}\n\\`}</style>`;\n}\n","/**\n * UIH DSL Codegen - Script Generator\n *\n * Generates event handler function stubs from IR script block.\n *\n * @module @uih-dsl/codegen-react/script\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function generateScript(ir: UIHIR): string[] {\n  return ir.script.map((entry) => {\n    return `function ${entry.handler}() {\n  // TODO: Implement ${entry.event} handler\n}`;\n  });\n}\n\nexport function generateScriptExports(handlers: string[]): string | null {\n  if (handlers.length === 0) {\n    return null;\n  }\n\n  return handlers.join(\"\\n\\n\");\n}\n","/**\n * UIH DSL Codegen - JSX Generator\n *\n * Generates JSX code from IR layout tree.\n *\n * @module @uih-dsl/codegen-react/jsx\n * @version 1.0.0\n */\n\nimport type { IRNode } from \"@uih-dsl/ir\";\n\nexport function generateJSX(nodes: IRNode[], indent: number = 0): string {\n  return nodes.map((node) => generateNode(node, indent)).join(\"\\n\");\n}\n\nfunction mapToHTMLTag(uihTag: string): string {\n  const htmlTagMap: Record<string, string> = {\n    // Layout\n    Div: \"div\",\n    Section: \"section\",\n    Article: \"article\",\n    Aside: \"aside\",\n    Header: \"header\",\n    Footer: \"footer\",\n    Nav: \"nav\",\n    Main: \"main\",\n    // Text\n    H1: \"h1\",\n    H2: \"h2\",\n    H3: \"h3\",\n    H4: \"h4\",\n    H5: \"h5\",\n    H6: \"h6\",\n    P: \"p\",\n    Span: \"span\",\n    Text: \"span\",\n    // Form\n    Form: \"form\",\n    Input: \"input\",\n    Textarea: \"textarea\",\n    Button: \"button\",\n    Label: \"label\",\n    Select: \"select\",\n    Option: \"option\",\n    // List\n    Ul: \"ul\",\n    Ol: \"ol\",\n    Li: \"li\",\n    // Table\n    Table: \"table\",\n    Thead: \"thead\",\n    Tbody: \"tbody\",\n    Tr: \"tr\",\n    Td: \"td\",\n    Th: \"th\",\n    // Media\n    Img: \"img\",\n    Video: \"video\",\n    Audio: \"audio\",\n    // Other\n    A: \"a\",\n    Card: \"div\",\n    CardContent: \"div\",\n  };\n\n  return htmlTagMap[uihTag] || \"div\";\n}\n\nfunction generateNode(node: IRNode, indent: number): string {\n  if (node.type === \"Text\") {\n    return generateTextNode(node, indent);\n  } else {\n    return generateComponentNode(node, indent);\n  }\n}\n\nfunction generateTextNode(node: { type: \"Text\"; value: string }, indent: number): string {\n  const indentStr = \" \".repeat(indent);\n  const escaped = escapeJSXText(node.value);\n  return `${indentStr}{\"${escaped}\"}`;\n}\n\nfunction generateComponentNode(\n  node: {\n    type: \"Component\";\n    tag: string;\n    attrs: Array<{ key: string; value: string }>;\n    children: IRNode[];\n  },\n  indent: number\n): string {\n  const indentStr = \" \".repeat(indent);\n  const tag = mapToHTMLTag(node.tag);\n  const attrs = generateAttributes(node.attrs);\n  const attrsStr = attrs.length > 0 ? \" \" + attrs : \"\";\n\n  if (node.children.length === 0) {\n    return `${indentStr}<${tag}${attrsStr} />`;\n  }\n\n  const childrenStr = generateJSX(node.children, indent + 2);\n  return `${indentStr}<${tag}${attrsStr}>\n${childrenStr}\n${indentStr}</${tag}>`;\n}\n\nfunction generateAttributes(attrs: Array<{ key: string; value: string }>): string {\n  return attrs.map((attr) => `${attr.key}=\"${escapeAttributeValue(attr.value)}\"`).join(\" \");\n}\n\nfunction escapeJSXText(text: string): string {\n  return text\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/\\t/g, \"\\\\t\");\n}\n\nfunction escapeAttributeValue(value: string): string {\n  return value\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n","/**\n * UIH DSL Codegen - Main Generator\n *\n * Orchestrates code generation from IR to final output.\n *\n * @module @uih-dsl/codegen-react/generator\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\nimport type { CodegenOutput, CodegenOptions } from \"./types.js\";\nimport { generateMeta } from \"./meta.js\";\nimport { generateStyle } from \"./style.js\";\nimport { generateScript, generateScriptExports } from \"./script.js\";\nimport { generateJSX } from \"./jsx.js\";\n\nconst DEFAULT_OPTIONS: CodegenOptions = {\n  componentName: \"Page\",\n  includeComments: true,\n  indentSize: 2,\n};\n\nexport function generate(ir: UIHIR, options: CodegenOptions = {}): CodegenOutput {\n  const opts: Required<CodegenOptions> = { ...DEFAULT_OPTIONS, ...options } as Required<CodegenOptions>;\n\n  const meta = generateMeta(ir);\n  const style = generateStyle(ir);\n  const events = generateScript(ir);\n  const scriptCode = generateScriptExports(events);\n\n  const code = generateFullCode(ir, meta, style, scriptCode, opts);\n\n  return {\n    code,\n    style,\n    meta,\n    events,\n  };\n}\n\nfunction generateFullCode(\n  ir: UIHIR,\n  meta: string | null,\n  style: string | null,\n  scriptCode: string | null,\n  opts: Required<CodegenOptions>\n): string {\n  const sections: string[] = [];\n\n  if (opts.includeComments && ir.errors.length > 0) {\n    sections.push(generateErrorComments(ir));\n  }\n\n  if (meta) {\n    sections.push(meta);\n  }\n\n  if (style) {\n    sections.push(`const styles = \\`\n${style}\n\\`;`);\n  }\n\n  if (scriptCode) {\n    sections.push(scriptCode);\n  }\n\n  const componentCode = generateComponent(ir, opts);\n  sections.push(componentCode);\n\n  return sections.join(\"\\n\\n\");\n}\n\nfunction generateErrorComments(ir: UIHIR): string {\n  const errors = ir.errors.map(\n    (err) => ` * - ${err.message} (line:${err.line}, col:${err.column})`\n  );\n\n  return `/* UIH WARNINGS:\n${errors.join(\"\\n\")}\n */`;\n}\n\nfunction generateComponent(ir: UIHIR, opts: Required<CodegenOptions>): string {\n  const jsx = generateJSX(ir.layout, opts.indentSize);\n\n  return `export default function ${opts.componentName}() {\n  return (\n${jsx}\n  );\n}`;\n}\n","/**\n * UIH DSL Codegen - Meta Generator (Vue)\n *\n * Generates Vue Router meta from IR meta block.\n *\n * @module @uih-dsl/codegen-vue/meta\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function generateMeta(ir: UIHIR): string | null {\n  const keys = Object.keys(ir.meta);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  const entries = keys.map((key) => {\n    const value = ir.meta[key];\n    const formattedValue = formatMetaValue(value);\n    return `  ${key}: ${formattedValue}`;\n  });\n\n  return `export const routeMeta = {\\n${entries.join(\",\\n\")}\\n};`;\n}\n\nfunction formatMetaValue(value: string | number | boolean): string {\n  if (typeof value === \"string\") {\n    return `\"${escapeString(value)}\"`;\n  }\n  return String(value);\n}\n\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/\\t/g, \"\\\\t\");\n}\n","/**\n * UIH DSL Codegen - Style Generator (Vue)\n *\n * Generates CSS variables from IR style tokens for Vue 3 SFC.\n *\n * @module @uih-dsl/codegen-vue/style\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\n/**\n * Generate CSS variables from IR style tokens.\n * Converts path arrays to CSS variable names with dash notation.\n *\n * @param ir - UIH IR structure\n * @returns CSS string with :root block, or null if no tokens\n */\nexport function generateStyle(ir: UIHIR): string | null {\n  if (ir.style.tokens.length === 0) {\n    return null;\n  }\n\n  const variables = ir.style.tokens.map((token) => {\n    const varName = token.path.join(\"-\");\n    const value = formatStyleValue(token.value);\n    return `  --${varName}: ${value};`;\n  });\n\n  return `:root {\\n${variables.join(\"\\n\")}\\n}`;\n}\n\n/**\n * Format style value for CSS output.\n */\nfunction formatStyleValue(value: string | number): string {\n  if (typeof value === \"number\") {\n    return String(value);\n  }\n  return value;\n}\n","/**\n * UIH DSL Codegen - Script Generator (Vue)\n *\n * Generates event handler function stubs from IR script block for Vue 3.\n *\n * @module @uih-dsl/codegen-vue/script\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function generateScript(ir: UIHIR): string[] {\n  return ir.script.map((entry) => {\n    return `const ${entry.handler} = () => {\n  // TODO: Implement ${entry.event} handler\n};`;\n  });\n}\n\nexport function generateScriptExports(handlers: string[]): string | null {\n  if (handlers.length === 0) {\n    return null;\n  }\n\n  return handlers.join(\"\\n\\n\");\n}\n","/**\n * UIH DSL Codegen - Template Generator (Vue)\n *\n * Generates Vue template code from IR layout tree.\n *\n * @module @uih-dsl/codegen-vue/template\n * @version 1.0.0\n */\n\nimport type { IRNode } from \"@uih-dsl/ir\";\n\nexport function generateTemplate(nodes: IRNode[], indent: number = 0): string {\n  return nodes.map((node) => generateNode(node, indent)).join(\"\\n\");\n}\n\nfunction mapToHTMLTag(uihTag: string): string {\n  const htmlTagMap: Record<string, string> = {\n    // Layout\n    Div: \"div\",\n    Section: \"section\",\n    Article: \"article\",\n    Aside: \"aside\",\n    Header: \"header\",\n    Footer: \"footer\",\n    Nav: \"nav\",\n    Main: \"main\",\n    // Text\n    H1: \"h1\",\n    H2: \"h2\",\n    H3: \"h3\",\n    H4: \"h4\",\n    H5: \"h5\",\n    H6: \"h6\",\n    P: \"p\",\n    Span: \"span\",\n    Text: \"span\",\n    // Form\n    Form: \"form\",\n    Input: \"input\",\n    Textarea: \"textarea\",\n    Button: \"button\",\n    Label: \"label\",\n    Select: \"select\",\n    Option: \"option\",\n    // List\n    Ul: \"ul\",\n    Ol: \"ol\",\n    Li: \"li\",\n    // Table\n    Table: \"table\",\n    Thead: \"thead\",\n    Tbody: \"tbody\",\n    Tr: \"tr\",\n    Td: \"td\",\n    Th: \"th\",\n    // Media\n    Img: \"img\",\n    Video: \"video\",\n    Audio: \"audio\",\n    // Other\n    A: \"a\",\n    Card: \"div\",\n    CardContent: \"div\",\n  };\n\n  return htmlTagMap[uihTag] || \"div\";\n}\n\nfunction generateNode(node: IRNode, indent: number): string {\n  if (node.type === \"Text\") {\n    return generateTextNode(node, indent);\n  } else {\n    return generateComponentNode(node, indent);\n  }\n}\n\nfunction generateTextNode(node: { type: \"Text\"; value: string }, indent: number): string {\n  const indentStr = \" \".repeat(indent);\n  const escaped = escapeTemplateText(node.value);\n  return `${indentStr}${escaped}`;\n}\n\nfunction generateComponentNode(\n  node: {\n    type: \"Component\";\n    tag: string;\n    attrs: Array<{ key: string; value: string }>;\n    children: IRNode[];\n  },\n  indent: number\n): string {\n  const indentStr = \" \".repeat(indent);\n  const tag = mapToHTMLTag(node.tag);\n  const attrs = generateAttributes(node.attrs);\n  const attrsStr = attrs.length > 0 ? \" \" + attrs : \"\";\n\n  if (node.children.length === 0) {\n    return `${indentStr}<${tag}${attrsStr} />`;\n  }\n\n  const childrenStr = generateTemplate(node.children, indent + 2);\n  return `${indentStr}<${tag}${attrsStr}>\n${childrenStr}\n${indentStr}</${tag}>`;\n}\n\nfunction generateAttributes(attrs: Array<{ key: string; value: string }>): string {\n  return attrs.map((attr) => `${attr.key}=\"${escapeAttributeValue(attr.value)}\"`).join(\" \");\n}\n\nfunction escapeTemplateText(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction escapeAttributeValue(value: string): string {\n  return value\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n","/**\n * UIH DSL Codegen - Main Generator (Vue)\n *\n * Orchestrates Vue 3 SFC generation from IR to final output.\n *\n * @module @uih-dsl/codegen-vue/generator\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\nimport type { CodegenOutput, CodegenOptions } from \"./types.js\";\nimport { generateMeta } from \"./meta.js\";\nimport { generateStyle } from \"./style.js\";\nimport { generateScript, generateScriptExports } from \"./script.js\";\nimport { generateTemplate } from \"./template.js\";\n\nconst DEFAULT_OPTIONS: CodegenOptions = {\n  componentName: \"Page\",\n  includeComments: true,\n  indentSize: 2,\n};\n\nexport function generate(ir: UIHIR, options: CodegenOptions = {}): CodegenOutput {\n  const opts: Required<CodegenOptions> = { ...DEFAULT_OPTIONS, ...options } as Required<CodegenOptions>;\n\n  const meta = generateMeta(ir);\n  const style = generateStyle(ir);\n  const events = generateScript(ir);\n  const scriptCode = generateScriptExports(events);\n\n  const code = generateFullCode(ir, meta, style, scriptCode, opts);\n\n  return {\n    code,\n    style,\n    meta,\n    events,\n  };\n}\n\nfunction generateFullCode(\n  ir: UIHIR,\n  meta: string | null,\n  style: string | null,\n  scriptCode: string | null,\n  opts: Required<CodegenOptions>\n): string {\n  const sections: string[] = [];\n\n  // Generate <script setup>\n  const scriptSection = generateScriptSection(ir, meta, scriptCode, opts);\n  if (scriptSection) {\n    sections.push(scriptSection);\n  }\n\n  // Generate <template>\n  const templateSection = generateTemplateSection(ir, opts);\n  sections.push(templateSection);\n\n  // Generate <style scoped>\n  if (style) {\n    const styleSection = `<style scoped>\n${style}\n</style>`;\n    sections.push(styleSection);\n  }\n\n  return sections.join(\"\\n\\n\");\n}\n\nfunction generateScriptSection(\n  ir: UIHIR,\n  meta: string | null,\n  scriptCode: string | null,\n  opts: Required<CodegenOptions>\n): string | null {\n  const scriptParts: string[] = [];\n\n  if (opts.includeComments && ir.errors.length > 0) {\n    scriptParts.push(generateErrorComments(ir));\n  }\n\n  if (meta) {\n    scriptParts.push(meta);\n  }\n\n  if (scriptCode) {\n    scriptParts.push(scriptCode);\n  }\n\n  if (scriptParts.length === 0) {\n    return null;\n  }\n\n  return `<script setup lang=\"ts\">\n${scriptParts.join(\"\\n\\n\")}\n</script>`;\n}\n\nfunction generateTemplateSection(ir: UIHIR, opts: Required<CodegenOptions>): string {\n  const template = generateTemplate(ir.layout, opts.indentSize);\n\n  return `<template>\n${template}\n</template>`;\n}\n\nfunction generateErrorComments(ir: UIHIR): string {\n  const errors = ir.errors.map(\n    (err) => ` * - ${err.message} (line:${err.line}, col:${err.column})`\n  );\n\n  return `/* UIH WARNINGS:\n${errors.join(\"\\n\")}\n */`;\n}\n","/**\n * UIH DSL Codegen - Meta Generator (Svelte)\n *\n * Generates Svelte component props from IR meta block.\n *\n * @module @uih-dsl/codegen-svelte/meta\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function generateMeta(ir: UIHIR): string | null {\n  const keys = Object.keys(ir.meta);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  const exports = keys.map((key) => {\n    const value = ir.meta[key];\n    const formattedValue = formatMetaValue(value);\n    return `export const ${key} = ${formattedValue};`;\n  });\n\n  return exports.join(\"\\n\");\n}\n\nfunction formatMetaValue(value: string | number | boolean): string {\n  if (typeof value === \"string\") {\n    return `\"${escapeString(value)}\"`;\n  }\n  return String(value);\n}\n\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/\\t/g, \"\\\\t\");\n}\n","/**\n * UIH DSL Codegen - Style Generator (Svelte)\n *\n * Generates CSS variables from IR style tokens for Svelte 5.\n *\n * @module @uih-dsl/codegen-svelte/style\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\n/**\n * Generate CSS variables from IR style tokens.\n * Converts path arrays to CSS variable names with dash notation.\n *\n * @param ir - UIH IR structure\n * @returns CSS string with :root block, or null if no tokens\n */\nexport function generateStyle(ir: UIHIR): string | null {\n  if (ir.style.tokens.length === 0) {\n    return null;\n  }\n\n  const variables = ir.style.tokens.map((token) => {\n    const varName = token.path.join(\"-\");\n    const value = formatStyleValue(token.value);\n    return `  --${varName}: ${value};`;\n  });\n\n  return `:global(:root) {\\n${variables.join(\"\\n\")}\\n}`;\n}\n\n/**\n * Format style value for CSS output.\n */\nfunction formatStyleValue(value: string | number): string {\n  if (typeof value === \"number\") {\n    return String(value);\n  }\n  return value;\n}\n","/**\n * UIH DSL Codegen - Script Generator (Svelte)\n *\n * Generates event handler function stubs from IR script block for Svelte 5.\n *\n * @module @uih-dsl/codegen-svelte/script\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\n\nexport function generateScript(ir: UIHIR): string[] {\n  return ir.script.map((entry) => {\n    return `function ${entry.handler}() {\n  // TODO: Implement ${entry.event} handler\n}`;\n  });\n}\n\nexport function generateScriptExports(handlers: string[]): string | null {\n  if (handlers.length === 0) {\n    return null;\n  }\n\n  return handlers.join(\"\\n\\n\");\n}\n","/**\n * UIH DSL Codegen - Template Generator (Svelte)\n *\n * Generates Svelte template code from IR layout tree.\n *\n * @module @uih-dsl/codegen-svelte/template\n * @version 1.0.0\n */\n\nimport type { IRNode } from \"@uih-dsl/ir\";\n\nexport function generateTemplate(nodes: IRNode[], indent: number = 0): string {\n  return nodes.map((node) => generateNode(node, indent)).join(\"\\n\");\n}\n\nfunction mapToHTMLTag(uihTag: string): string {\n  const htmlTagMap: Record<string, string> = {\n    // Layout\n    Div: \"div\",\n    Section: \"section\",\n    Article: \"article\",\n    Aside: \"aside\",\n    Header: \"header\",\n    Footer: \"footer\",\n    Nav: \"nav\",\n    Main: \"main\",\n    // Text\n    H1: \"h1\",\n    H2: \"h2\",\n    H3: \"h3\",\n    H4: \"h4\",\n    H5: \"h5\",\n    H6: \"h6\",\n    P: \"p\",\n    Span: \"span\",\n    Text: \"span\",\n    // Form\n    Form: \"form\",\n    Input: \"input\",\n    Textarea: \"textarea\",\n    Button: \"button\",\n    Label: \"label\",\n    Select: \"select\",\n    Option: \"option\",\n    // List\n    Ul: \"ul\",\n    Ol: \"ol\",\n    Li: \"li\",\n    // Table\n    Table: \"table\",\n    Thead: \"thead\",\n    Tbody: \"tbody\",\n    Tr: \"tr\",\n    Td: \"td\",\n    Th: \"th\",\n    // Media\n    Img: \"img\",\n    Video: \"video\",\n    Audio: \"audio\",\n    // Other\n    A: \"a\",\n    Card: \"div\",\n    CardContent: \"div\",\n  };\n\n  return htmlTagMap[uihTag] || \"div\";\n}\n\nfunction generateNode(node: IRNode, indent: number): string {\n  if (node.type === \"Text\") {\n    return generateTextNode(node, indent);\n  } else {\n    return generateComponentNode(node, indent);\n  }\n}\n\nfunction generateTextNode(node: { type: \"Text\"; value: string }, indent: number): string {\n  const indentStr = \" \".repeat(indent);\n  const escaped = escapeTemplateText(node.value);\n  return `${indentStr}${escaped}`;\n}\n\nfunction generateComponentNode(\n  node: {\n    type: \"Component\";\n    tag: string;\n    attrs: Array<{ key: string; value: string }>;\n    children: IRNode[];\n  },\n  indent: number\n): string {\n  const indentStr = \" \".repeat(indent);\n  const tag = mapToHTMLTag(node.tag);\n  const attrs = generateAttributes(node.attrs);\n  const attrsStr = attrs.length > 0 ? \" \" + attrs : \"\";\n\n  if (node.children.length === 0) {\n    return `${indentStr}<${tag}${attrsStr} />`;\n  }\n\n  const childrenStr = generateTemplate(node.children, indent + 2);\n  return `${indentStr}<${tag}${attrsStr}>\n${childrenStr}\n${indentStr}</${tag}>`;\n}\n\nfunction generateAttributes(attrs: Array<{ key: string; value: string }>): string {\n  return attrs.map((attr) => `${attr.key}=\"${escapeAttributeValue(attr.value)}\"`).join(\" \");\n}\n\nfunction escapeTemplateText(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction escapeAttributeValue(value: string): string {\n  return value\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n","/**\n * UIH DSL Codegen - Main Generator (Svelte)\n *\n * Orchestrates Svelte 5 component generation from IR to final output.\n *\n * @module @uih-dsl/codegen-svelte/generator\n * @version 1.0.0\n */\n\nimport type { UIHIR } from \"@uih-dsl/ir\";\nimport type { CodegenOutput, CodegenOptions } from \"./types.js\";\nimport { generateMeta } from \"./meta.js\";\nimport { generateStyle } from \"./style.js\";\nimport { generateScript, generateScriptExports } from \"./script.js\";\nimport { generateTemplate } from \"./template.js\";\n\nconst DEFAULT_OPTIONS: CodegenOptions = {\n  componentName: \"Page\",\n  includeComments: true,\n  indentSize: 2,\n};\n\nexport function generate(ir: UIHIR, options: CodegenOptions = {}): CodegenOutput {\n  const opts: Required<CodegenOptions> = { ...DEFAULT_OPTIONS, ...options } as Required<CodegenOptions>;\n\n  const meta = generateMeta(ir);\n  const style = generateStyle(ir);\n  const events = generateScript(ir);\n  const scriptCode = generateScriptExports(events);\n\n  const code = generateFullCode(ir, meta, style, scriptCode, opts);\n\n  return {\n    code,\n    style,\n    meta,\n    events,\n  };\n}\n\nfunction generateFullCode(\n  ir: UIHIR,\n  meta: string | null,\n  style: string | null,\n  scriptCode: string | null,\n  opts: Required<CodegenOptions>\n): string {\n  const sections: string[] = [];\n\n  // Generate <script lang=\"ts\">\n  const scriptSection = generateScriptSection(ir, meta, scriptCode, opts);\n  if (scriptSection) {\n    sections.push(scriptSection);\n  }\n\n  // Generate template (no wrapper tag in Svelte)\n  const template = generateTemplate(ir.layout, opts.indentSize);\n  sections.push(template);\n\n  // Generate <style>\n  if (style) {\n    const styleSection = `<style>\n${style}\n</style>`;\n    sections.push(styleSection);\n  }\n\n  return sections.join(\"\\n\\n\");\n}\n\nfunction generateScriptSection(\n  ir: UIHIR,\n  meta: string | null,\n  scriptCode: string | null,\n  opts: Required<CodegenOptions>\n): string | null {\n  const scriptParts: string[] = [];\n\n  if (opts.includeComments && ir.errors.length > 0) {\n    scriptParts.push(generateErrorComments(ir));\n  }\n\n  if (meta) {\n    scriptParts.push(meta);\n  }\n\n  if (scriptCode) {\n    scriptParts.push(scriptCode);\n  }\n\n  if (scriptParts.length === 0) {\n    return null;\n  }\n\n  return `<script lang=\"ts\">\n${scriptParts.join(\"\\n\\n\")}\n</script>`;\n}\n\nfunction generateErrorComments(ir: UIHIR): string {\n  const errors = ir.errors.map(\n    (err) => ` * - ${err.message} (line:${err.line}, col:${err.column})`\n  );\n\n  return `/* UIH WARNINGS:\n${errors.join(\"\\n\")}\n */`;\n}\n"],"mappings":"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","names":["TokenType","TokenizerMode","generateMeta","formatMetaValue","escapeString","generateStyle","formatStyleValue","generateScript","generateScriptExports","generateNode","mapToHTMLTag","generateTextNode","generateComponentNode","generateAttributes","escapeAttributeValue","DEFAULT_OPTIONS","generate","generateMeta","generateStyle","generateScript","generateScriptExports","generateFullCode","generateErrorComments","generateMeta","exports","formatMetaValue","escapeString","generateStyle","formatStyleValue","generateScript","generateScriptExports","generateTemplate","generateNode","mapToHTMLTag","generateTextNode","generateComponentNode","escapeTemplateText","generateAttributes","escapeAttributeValue","DEFAULT_OPTIONS","generate","generateMeta","generateStyle","generateScript","generateScriptExports","generateFullCode","generateScriptSection","generateTemplate","generateErrorComments","generate"]}